{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/shiro/source/favicon.svg","path":"favicon.svg","modified":0,"renderable":1},{"_id":"themes/shiro/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/shiro/source/js/lightgallery.js","path":"js/lightgallery.js","modified":0,"renderable":1},{"_id":"themes/shiro/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/xztl.png","path":"images/xztl.png","modified":0,"renderable":0},{"_id":"source/images/avatar-carton.png","path":"images/avatar-carton.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/bad-loop-exit.png","path":"images/bad-loop-exit.png","modified":0,"renderable":0},{"_id":"source/images/bad-loop1.jpg","path":"images/bad-loop1.jpg","modified":0,"renderable":0},{"_id":"source/images/bad-regalloc-regression.png","path":"images/bad-regalloc-regression.png","modified":0,"renderable":0},{"_id":"source/images/bad-test-controls-many.svg","path":"images/bad-test-controls-many.svg","modified":0,"renderable":0},{"_id":"source/images/bad_use_block.svg","path":"images/bad_use_block.svg","modified":0,"renderable":0},{"_id":"source/images/block-layout-v1.svg","path":"images/block-layout-v1.svg","modified":0,"renderable":0},{"_id":"source/images/block-layout-v2.svg","path":"images/block-layout-v2.svg","modified":0,"renderable":0},{"_id":"source/images/book.jpg","path":"images/book.jpg","modified":0,"renderable":0},{"_id":"source/images/bug-b2l-miss.svg","path":"images/bug-b2l-miss.svg","modified":0,"renderable":0},{"_id":"source/images/bug_jmptable_exit.svg","path":"images/bug_jmptable_exit.svg","modified":0,"renderable":0},{"_id":"source/images/fig1.png","path":"images/fig1.png","modified":0,"renderable":0},{"_id":"source/images/fig2.png","path":"images/fig2.png","modified":0,"renderable":0},{"_id":"source/images/fig3.jpg","path":"images/fig3.jpg","modified":0,"renderable":0},{"_id":"source/images/fig4.jpg","path":"images/fig4.jpg","modified":0,"renderable":0},{"_id":"source/images/flow.png","path":"images/flow.png","modified":0,"renderable":0},{"_id":"source/images/hoist_bound_check_after.svg","path":"images/hoist_bound_check_after.svg","modified":0,"renderable":0},{"_id":"source/images/hoist_bound_check_before.svg","path":"images/hoist_bound_check_before.svg","modified":0,"renderable":0},{"_id":"source/images/tjump.png","path":"images/tjump.png","modified":0,"renderable":0},{"_id":"source/images/xiaozhuan-name.png","path":"images/xiaozhuan-name.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1768962644241},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1768962660732},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1768962660732},{"_id":"source/categories/index.md","hash":"ffb7317a4e79d6d79952ad4c449c0a57b43e4bb8","modified":1768963236398},{"_id":"source/tags/index.md","hash":"9e03c234d18be0b022e291bc89484854551f8c76","modified":1768963224356},{"_id":"themes/shiro/LICENSE","hash":"a9423e7ce19a496166af32bed9f2a6cdc4784a1a","modified":1768963118117},{"_id":"themes/shiro/.gitignore","hash":"565750e1fa71d479e5516aa3686b97c24ce02e2f","modified":1768963118117},{"_id":"themes/shiro/README.md","hash":"96ded5634eef35f6b890aa9f0f704eccf3890380","modified":1768963118117},{"_id":"themes/shiro/_config.yml","hash":"23f09367b862a4cb166eee9d3f0db93084e49ef1","modified":1768963118117},{"_id":"themes/shiro/package-lock.json","hash":"5851eca60edaebe52ff10935572c9438a63fcea5","modified":1768963118121},{"_id":"themes/shiro/languages/default.yml","hash":"5b74528e3db1cd4fca5042bdbfca941bac2e4fe3","modified":1768963118118},{"_id":"themes/shiro/languages/en.yml","hash":"5b74528e3db1cd4fca5042bdbfca941bac2e4fe3","modified":1768963118118},{"_id":"themes/shiro/package.json","hash":"c0bbeb2d41854e747f6148c7313fca3bc088e9d4","modified":1768963118121},{"_id":"themes/shiro/languages/fr-FR.yml","hash":"1b67a476a803dd5eb81ebc2b4762e1bc26dcfdf3","modified":1768963118118},{"_id":"themes/shiro/languages/en-US.yml","hash":"5b74528e3db1cd4fca5042bdbfca941bac2e4fe3","modified":1768963118118},{"_id":"themes/shiro/languages/ja-JP.yml","hash":"84da889dd9b9a88ba2b8fbb0b435447a3c655a5d","modified":1768963118118},{"_id":"themes/shiro/languages/ja.yml","hash":"84da889dd9b9a88ba2b8fbb0b435447a3c655a5d","modified":1768963118118},{"_id":"themes/shiro/languages/zh-CN.yml","hash":"1569798832c17c34d252bfd73d45d68fccc7fbca","modified":1768963118118},{"_id":"themes/shiro/languages/fr.yml","hash":"1b67a476a803dd5eb81ebc2b4762e1bc26dcfdf3","modified":1768963118118},{"_id":"themes/shiro/languages/zh-TW.yml","hash":"f1a6f11322bee1ab8d220fe1fd9c2bbc774519b8","modified":1768963118118},{"_id":"themes/shiro/layout/_layout.njk","hash":"ee410daf521ec528dc869f0f38eb9dcfee2018ad","modified":1768963118118},{"_id":"themes/shiro/layout/archive.njk","hash":"b85ef3c501b7a1e63cb3fd392bc7784a6c64d0d8","modified":1768963118120},{"_id":"themes/shiro/layout/index.njk","hash":"825be6826e2c6a4204966f28b4109caeaa4b7901","modified":1768963118120},{"_id":"themes/shiro/layout/category.njk","hash":"76856764bb7cb1c1862a38a4e0362f51f424b926","modified":1768963118120},{"_id":"themes/shiro/layout/page.njk","hash":"2b003e7dba8b80157e79941b79c1fb00b7ca8556","modified":1768963118120},{"_id":"themes/shiro/layout/post.njk","hash":"fe4ea0f7bdfa35f12321fac3d5f14270f178cea8","modified":1768963118120},{"_id":"themes/shiro/layout/tag.njk","hash":"319a8b2794087809ee8216d9b4b22b1fec099cf0","modified":1768963118120},{"_id":"themes/shiro/layout/_macro/archive.njk","hash":"d2930918b17b87a9addd134c22d35ff308e3e55b","modified":1768963118118},{"_id":"themes/shiro/source/css/_tailwind.css","hash":"e73350a37d40b02c97f5cd773a92695c4fed4bbf","modified":1768963118121},{"_id":"themes/shiro/layout/_macro/ui.njk","hash":"710f8f81799285df5712da7f7bdf552446ceb4ca","modified":1768963118119},{"_id":"themes/shiro/source/css/style.min.css","hash":"c570a18b7afe0b16e95bd5a8d7e75476a8848b55","modified":1768963118121},{"_id":"themes/shiro/source/js/main.js","hash":"9d08a201202d600853afffc5c7a0b4c91671d9c0","modified":1768963118122},{"_id":"themes/shiro/layout/_partial/comments/disqus.njk","hash":"91eb919be281f1d2b02a0a3a226d82445594b8b3","modified":1768963118119},{"_id":"themes/shiro/layout/_partial/analytics/google.njk","hash":"34e7a3b844e6c895c19895f837e0449e0ba8139c","modified":1768963118119},{"_id":"themes/shiro/source/js/lightgallery.js","hash":"e20e329950d36ab4c80ca549341011927f3de1cc","modified":1768963118122},{"_id":"themes/shiro/source/favicon.svg","hash":"7c32d6b1f835ba5075df93261f1f40bd0273b051","modified":1768963118121},{"_id":"themes/shiro/layout/_partial/common/empty.njk","hash":"93b49c857d67faeec993be72b31e25ce73e9d2f0","modified":1768963118119},{"_id":"themes/shiro/layout/_partial/common/head.njk","hash":"eeef40d4cdf82fbb516d3c38e6108025bee37b82","modified":1768963118119},{"_id":"themes/shiro/layout/_partial/common/footer.njk","hash":"a9da7754c009cd99b9b08fd300d0e0c1c000439e","modified":1768963118119},{"_id":"themes/shiro/layout/_partial/common/pagination.njk","hash":"0c47893fd3358d0b0909b8c200d64e74ca6be214","modified":1768963118120},{"_id":"themes/shiro/layout/_partial/common/header.njk","hash":"56e14ca9660e95e655700bad9858708823f19226","modified":1768963118120},{"_id":"themes/shiro/layout/_partial/components/post-card.njk","hash":"deeb704cf8f00aa861eb7b771e24547043a21158","modified":1768963118120},{"_id":"source/_posts/golang-sccp.md","hash":"ff8bfef48be640cc6d9f4f950179a6ad6c43995b","modified":1768964951496},{"_id":"source/_posts/inference.md","hash":"463f32298c0271a6c0de1961282dc5c5dfe59feb","modified":1768964410775},{"_id":"source/images/xztl.png","hash":"6834fac5c4c9812b4e2676a384ae852b9cbf2a05","modified":1768964284144},{"_id":"source/images copy/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1768965117347},{"_id":"source/images copy/avatar-carton.png","hash":"675b6503a1b0ed4965d6b41d3066e18589f9fff3","modified":1768965117349},{"_id":"source/images copy/avatar.jpg","hash":"913f61579a317645a256fa2ad350419438e8cbc7","modified":1768965117351},{"_id":"source/images copy/bad-loop-exit.png","hash":"56101441fb547043f2c1181b2894ed58d34df078","modified":1768965117353},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1768965117347},{"_id":"source/images/avatar-carton.png","hash":"675b6503a1b0ed4965d6b41d3066e18589f9fff3","modified":1768965117349},{"_id":"source/images/block-layout-v2.svg","hash":"65855f0ae7d6ad490f51d760c2c7ba08756526c0","modified":1768965117364},{"_id":"source/images/block-layout-v1.svg","hash":"b6b3a83e1f172f535875c675dbaf53a65e893cb3","modified":1768965117363},{"_id":"source/images/hoist_bound_check_after.svg","hash":"102af11cf4a3f58ef241bea3ef94ebdb8e2eb0d3","modified":1768965117378},{"_id":"source/images/tjump.png","hash":"b192d2b1171dd6933a0b7f9fe5b4b67ac591dcdc","modified":1768965117379},{"_id":"source/images/flow.png","hash":"cab4ef89b121872958f771e0b927358014093bdb","modified":1768965117377},{"_id":"source/images/hoist_bound_check_before.svg","hash":"b11a892f6ce02fe65b3126633219f6db2faf5e01","modified":1768965117378},{"_id":"source/images/xiaozhuan-name.png","hash":"56562f2648a392adc97d1cfc1fc9ee4b25d67d76","modified":1768965117379},{"_id":"source/images/bad-test-controls-many.svg","hash":"957aee566c6f17a4f8557525bca3c20b4d687f04","modified":1768965117358},{"_id":"source/images/book.jpg","hash":"7d6eed6134f11adc4a75f42156bd783265de9d7b","modified":1768965117365},{"_id":"source/images/fig3.jpg","hash":"1e39d15fc4350d814aadd77955f80c2103fac531","modified":1768965117375},{"_id":"source/images/avatar.jpg","hash":"913f61579a317645a256fa2ad350419438e8cbc7","modified":1768965117351},{"_id":"source/images/bad-regalloc-regression.png","hash":"25e9810b1d37d622ec47cbe8a6cc861d5d4d1e08","modified":1768965117357},{"_id":"source/images/bad-loop1.jpg","hash":"609cf5ae564ae53791bc8b05fcabd2499adc356b","modified":1768965117354},{"_id":"source/images/bug_jmptable_exit.svg","hash":"e9e2410dfafe7581d9b31b20067340386fbeb3cb","modified":1768965117367},{"_id":"source/images/fig4.jpg","hash":"b983172df6cdccd5ce25114c6da93d5ba87f75cd","modified":1768965117376},{"_id":"source/images/bad-loop-exit.png","hash":"56101441fb547043f2c1181b2894ed58d34df078","modified":1768965117353},{"_id":"source/images/bad_use_block.svg","hash":"4d23867a7eea128f3dde4ca86fdf1eaab50618b5","modified":1768965117359},{"_id":"source/images/bug-b2l-miss.svg","hash":"1cdc9531dc4b15dc6ebeff4c54b38f8460def127","modified":1768965117367},{"_id":"source/images/fig1.png","hash":"7cafad42676d9cb5d859f98fbf95059621d8d50a","modified":1768965117370},{"_id":"source/images/fig2.png","hash":"44160e09813aa169f2164e5b4aa6527414f22285","modified":1768965117374},{"_id":"source/_posts/golang-licm.md","hash":"e4aaf6d5c03916156b72d2278abad40e2cd4cfc1","modified":1768965456617},{"_id":"source/_posts/two-phase-segmented-heapdump.md","hash":"42b867a47e380f241e7cab5dc576a413157e2221","modified":1768965141469}],"Category":[{"name":"Misc","_id":"cmknfoyfh00009dpx9nlpbiaw"},{"name":"Backup","parent":"cmknfoyfh00009dpx9nlpbiaw","_id":"cmknfpvkg00029dpx1xbeek8z"},{"name":"Golang","_id":"cmknft4dr00079dpx5iycdy35"},{"name":"Compiler","parent":"cmknft4dr00079dpx5iycdy35","_id":"cmknft4dr00089dpx59tk54o1"},{"name":"Compiler","_id":"cmkng22em00000opxa4epgqhn"},{"name":"Golang","parent":"cmkng22em00000opxa4epgqhn","_id":"cmkng22en00010opx4owtdsym"},{"name":"JVM","_id":"cmkng4iv5000134px2vcu205u"}],"Data":[],"Page":[{"title":"categories","layout":"category","date":"2026-01-21T02:40:05.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\nlayout: category\ndate: 2026-01-21 10:40:05\n---\n","updated":"2026-01-21T02:40:36.398Z","path":"categories/index.html","comments":1,"_id":"cmknf8h8p00013spxfl093ljz","content":"","excerpt":"","more":""}],"Post":[{"layout":"post","title":"2018年刑侦科推理试题","date":"2018-03-01T16:00:00.000Z","_content":"\n![](../images/xztl.png)\n最近很火的刑侦推理题。。。我也是试了一下，答案是BCACA CDABA\n\n如果直接推理是很难的，但借助计算机可以暴力无脑出结果(因为总共只有4^9=262144种情况)。具体做法是\n1.首先生成所有可能的答案（递归生成解答树）\n2.筛选掉不符合题目要求的（剪枝）\n3.剩下唯一一个就是答案\n\n附source code:https://pastebin.com/2a17Eqwu\n```cpp\n\n#include <algorithm>\n#include <iostream>\n#define pass\n\nchar answers[10];\n\n// Auxiliary functions\nint findMaxCount() {\n    int abcd[4];\n    for (int i = 0; i < 10; i++) {\n        abcd[answers[i] - 'A']++;\n    }\n    return *std::max_element(abcd, abcd + 4);\n};\nint findMinCount() {\n    int abcd[4];\n    for (int i = 0; i < 10; i++) {\n        abcd[answers[i] - 'A']++;\n    }\n    return *std::min_element(abcd, abcd + 4);\n};\n \nbool sameWithProblem8(int prob1, int probl2) {\n    char problem8Anaswer = answers[7];\n    if (problem8Anaswer == 'A') {\n        if (answers[prob1 - 1] != 'A' || answers[probl2 - 1] != 'A')\n            return false;\n    }\n    else if (problem8Anaswer == 'B') {\n        if (answers[prob1 - 1] != 'B' || answers[probl2 - 1] != 'B')\n            return false;\n    }\n    else if (problem8Anaswer == 'C') {\n        if (answers[prob1 - 1] != 'C' || answers[probl2 - 1] != 'C')\n            return false;\n    }\n    else if (problem8Anaswer == 'D') {\n        if (answers[prob1 - 1] != 'D' || answers[probl2 - 1] != 'D')\n            return false;\n    }\n    else {\n        static_assert(true, \"should not reach here\");\n    }\n    return true;\n};\n \n// BCACA CDABA\n// All 4^9=262144 occurrences could be enumerated in the solution tree\nvoid enumerateing(int problemCnt) {\n    if (problemCnt == 10) {\n        // Check 1\n        pass;\n        // Check 2\n        if (answers[1] == 'A') {\n            if (answers[4] != 'C')\n                return;\n        }\n        else if (answers[1] == 'B') {\n            if (answers[4] != 'D')\n                return;\n        }\n        else if (answers[1] == 'C') {\n            if (answers[4] != 'A')\n                return;\n        }\n        else if (answers[1] == 'D') {\n            if (answers[4] != 'B')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 3\n        if (answers[2] == 'A') {\n            if (answers[2] == answers[5] || answers[2] == answers[1] || answers[2] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'B') {\n            if (answers[5] == answers[2] || answers[5] == answers[1] || answers[5] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'C') {\n            if (answers[1] == answers[2] || answers[1] == answers[5] || answers[1] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'D') {\n            if (answers[3] == answers[2] || answers[3] == answers[5] || answers[3] == answers[1])\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 4\n        if (answers[3] == 'A') {\n            if (answers[0] != answers[4])\n                return;\n        }\n        else if (answers[3] == 'B') {\n            if (answers[1] != answers[6])\n                return;\n        }\n        else if (answers[3] == 'C') {\n            if (answers[0] != answers[8])\n                return;\n        }\n        else if (answers[3] == 'D') {\n            if (answers[5] != answers[9])\n                return;\n        }\n        else {\n            static_assert(true, \"should  not reach here\");\n        }\n        // Check 5\n        if (answers[4] == 'A') {\n            if (answers[7] != 'A')\n                return;\n        }\n        else if (answers[4] == 'B') {\n            if (answers[3] != 'B')\n                return;\n        }\n        else if (answers[4] == 'C') {\n            if (answers[8] != 'C')\n                return;\n        }\n        else if (answers[4] == 'D') {\n            if (answers[6] != 'D')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 6\n        if (answers[5] == 'A') {\n            if (!sameWithProblem8(2, 4))\n                return;\n        }\n        else if (answers[5] == 'B') {\n            if (!sameWithProblem8(1, 6))\n                return;\n        }\n        else if (answers[5] == 'C') {\n            if (!sameWithProblem8(3, 10))\n                return;\n        }\n        else if (answers[5] == 'D') {\n            if (!sameWithProblem8(5, 9))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n \n        // Check 7\n        int abcd[4];\n        for (int i = 0; i < 10; i++) {\n            abcd[answers[i] - 'A']++;\n        }\n        char whichCharMinCount = 'A';\n        int min = abcd[0];\n        for (int k = 1; k < 4; k++) {\n            if (abcd[k] < min) {\n                min = abcd[k];\n                whichCharMinCount = 'A' + k;\n            }\n        }\n        if (answers[6] == 'A') {\n            if (whichCharMinCount != 'C')\n                return;\n        }\n        else if (answers[6] == 'B') {\n            if (whichCharMinCount != 'B')\n                return;\n        }\n        else if (answers[6] == 'C') {\n            if (whichCharMinCount != 'A')\n                return;\n        }\n        else if (answers[6] == 'D') {\n            if (whichCharMinCount != 'D')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 8\n        auto nearProblem1 = [=](int prob1)->bool {\n            char problem1Answer = answers[0];\n            if ((answers[prob1 - 1] - 1) == problem1Answer || (answers[prob1 - 1] + 1) == problem1Answer)\n                return true;\n            return false;\n        };\n        if (answers[7] == 'A') {\n            if (nearProblem1(7))\n                return;\n        }\n        else if (answers[7] == 'B') {\n            if (nearProblem1(5))\n                return;\n        }\n        else if (answers[7] == 'C') {\n            if (nearProblem1(2))\n                return;\n        }\n        else if (answers[7] == 'D') {\n            if (nearProblem1(10))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 9\n        if (answers[8] == 'A') {\n            if ((answers[0] == answers[5] && answers[5] == answers[4]) ||\n                (answers[0] != answers[5] && answers[5] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'B') {\n            if ((answers[0] == answers[5] && answers[9] == answers[4]) ||\n                (answers[0] != answers[5] && answers[9] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'C') {\n            if ((answers[0] == answers[5] && answers[1] == answers[4]) ||\n                (answers[0] != answers[5] && answers[1] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'D') {\n            if ((answers[0] == answers[5] && answers[8] == answers[4]) ||\n                (answers[0] != answers[5] && answers[8] != answers[4]))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n \n        // Check 10\n        int diff = findMaxCount() - findMinCount();\n        if (answers[9] == 'A') {\n            if (diff != 3)\n                return;\n        }\n        else if (answers[9] == 'B') {\n            if (diff != 2)\n                return;\n        }\n        else if (answers[9] == 'C') {\n            if (diff != 4)\n                return;\n        }\n        else if (answers[9] == 'D') {\n            if (diff != 1)\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Finally, we got the unique solution and print it\n        std::cout << \"Finally we got the unqiue solution:\\n\";\n        for (auto x : answers) {\n            std::cout << x;\n        }\n        std::cout << \"\\n\";\n        return;\n    }\n    for (char i = 0; i < 4; i++) {\n        answers[problemCnt] = i + 'A';\n        enumerateing(problemCnt + 1);\n    }\n}\n \nint main() {\n    enumerateing(0);\n    getchar();\n    return 0;\n}\n```\n","source":"_posts/inference.md","raw":"---\nlayout: post\ntitle:  \"2018年刑侦科推理试题\"\ndate:   2018-03-2\ncategories: [Misc]\n---\n\n![](../images/xztl.png)\n最近很火的刑侦推理题。。。我也是试了一下，答案是BCACA CDABA\n\n如果直接推理是很难的，但借助计算机可以暴力无脑出结果(因为总共只有4^9=262144种情况)。具体做法是\n1.首先生成所有可能的答案（递归生成解答树）\n2.筛选掉不符合题目要求的（剪枝）\n3.剩下唯一一个就是答案\n\n附source code:https://pastebin.com/2a17Eqwu\n```cpp\n\n#include <algorithm>\n#include <iostream>\n#define pass\n\nchar answers[10];\n\n// Auxiliary functions\nint findMaxCount() {\n    int abcd[4];\n    for (int i = 0; i < 10; i++) {\n        abcd[answers[i] - 'A']++;\n    }\n    return *std::max_element(abcd, abcd + 4);\n};\nint findMinCount() {\n    int abcd[4];\n    for (int i = 0; i < 10; i++) {\n        abcd[answers[i] - 'A']++;\n    }\n    return *std::min_element(abcd, abcd + 4);\n};\n \nbool sameWithProblem8(int prob1, int probl2) {\n    char problem8Anaswer = answers[7];\n    if (problem8Anaswer == 'A') {\n        if (answers[prob1 - 1] != 'A' || answers[probl2 - 1] != 'A')\n            return false;\n    }\n    else if (problem8Anaswer == 'B') {\n        if (answers[prob1 - 1] != 'B' || answers[probl2 - 1] != 'B')\n            return false;\n    }\n    else if (problem8Anaswer == 'C') {\n        if (answers[prob1 - 1] != 'C' || answers[probl2 - 1] != 'C')\n            return false;\n    }\n    else if (problem8Anaswer == 'D') {\n        if (answers[prob1 - 1] != 'D' || answers[probl2 - 1] != 'D')\n            return false;\n    }\n    else {\n        static_assert(true, \"should not reach here\");\n    }\n    return true;\n};\n \n// BCACA CDABA\n// All 4^9=262144 occurrences could be enumerated in the solution tree\nvoid enumerateing(int problemCnt) {\n    if (problemCnt == 10) {\n        // Check 1\n        pass;\n        // Check 2\n        if (answers[1] == 'A') {\n            if (answers[4] != 'C')\n                return;\n        }\n        else if (answers[1] == 'B') {\n            if (answers[4] != 'D')\n                return;\n        }\n        else if (answers[1] == 'C') {\n            if (answers[4] != 'A')\n                return;\n        }\n        else if (answers[1] == 'D') {\n            if (answers[4] != 'B')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 3\n        if (answers[2] == 'A') {\n            if (answers[2] == answers[5] || answers[2] == answers[1] || answers[2] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'B') {\n            if (answers[5] == answers[2] || answers[5] == answers[1] || answers[5] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'C') {\n            if (answers[1] == answers[2] || answers[1] == answers[5] || answers[1] == answers[3])\n                return;\n        }\n        else if (answers[2] == 'D') {\n            if (answers[3] == answers[2] || answers[3] == answers[5] || answers[3] == answers[1])\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 4\n        if (answers[3] == 'A') {\n            if (answers[0] != answers[4])\n                return;\n        }\n        else if (answers[3] == 'B') {\n            if (answers[1] != answers[6])\n                return;\n        }\n        else if (answers[3] == 'C') {\n            if (answers[0] != answers[8])\n                return;\n        }\n        else if (answers[3] == 'D') {\n            if (answers[5] != answers[9])\n                return;\n        }\n        else {\n            static_assert(true, \"should  not reach here\");\n        }\n        // Check 5\n        if (answers[4] == 'A') {\n            if (answers[7] != 'A')\n                return;\n        }\n        else if (answers[4] == 'B') {\n            if (answers[3] != 'B')\n                return;\n        }\n        else if (answers[4] == 'C') {\n            if (answers[8] != 'C')\n                return;\n        }\n        else if (answers[4] == 'D') {\n            if (answers[6] != 'D')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 6\n        if (answers[5] == 'A') {\n            if (!sameWithProblem8(2, 4))\n                return;\n        }\n        else if (answers[5] == 'B') {\n            if (!sameWithProblem8(1, 6))\n                return;\n        }\n        else if (answers[5] == 'C') {\n            if (!sameWithProblem8(3, 10))\n                return;\n        }\n        else if (answers[5] == 'D') {\n            if (!sameWithProblem8(5, 9))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n \n        // Check 7\n        int abcd[4];\n        for (int i = 0; i < 10; i++) {\n            abcd[answers[i] - 'A']++;\n        }\n        char whichCharMinCount = 'A';\n        int min = abcd[0];\n        for (int k = 1; k < 4; k++) {\n            if (abcd[k] < min) {\n                min = abcd[k];\n                whichCharMinCount = 'A' + k;\n            }\n        }\n        if (answers[6] == 'A') {\n            if (whichCharMinCount != 'C')\n                return;\n        }\n        else if (answers[6] == 'B') {\n            if (whichCharMinCount != 'B')\n                return;\n        }\n        else if (answers[6] == 'C') {\n            if (whichCharMinCount != 'A')\n                return;\n        }\n        else if (answers[6] == 'D') {\n            if (whichCharMinCount != 'D')\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 8\n        auto nearProblem1 = [=](int prob1)->bool {\n            char problem1Answer = answers[0];\n            if ((answers[prob1 - 1] - 1) == problem1Answer || (answers[prob1 - 1] + 1) == problem1Answer)\n                return true;\n            return false;\n        };\n        if (answers[7] == 'A') {\n            if (nearProblem1(7))\n                return;\n        }\n        else if (answers[7] == 'B') {\n            if (nearProblem1(5))\n                return;\n        }\n        else if (answers[7] == 'C') {\n            if (nearProblem1(2))\n                return;\n        }\n        else if (answers[7] == 'D') {\n            if (nearProblem1(10))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Check 9\n        if (answers[8] == 'A') {\n            if ((answers[0] == answers[5] && answers[5] == answers[4]) ||\n                (answers[0] != answers[5] && answers[5] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'B') {\n            if ((answers[0] == answers[5] && answers[9] == answers[4]) ||\n                (answers[0] != answers[5] && answers[9] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'C') {\n            if ((answers[0] == answers[5] && answers[1] == answers[4]) ||\n                (answers[0] != answers[5] && answers[1] != answers[4]))\n                return;\n        }\n        else if (answers[8] == 'D') {\n            if ((answers[0] == answers[5] && answers[8] == answers[4]) ||\n                (answers[0] != answers[5] && answers[8] != answers[4]))\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n \n        // Check 10\n        int diff = findMaxCount() - findMinCount();\n        if (answers[9] == 'A') {\n            if (diff != 3)\n                return;\n        }\n        else if (answers[9] == 'B') {\n            if (diff != 2)\n                return;\n        }\n        else if (answers[9] == 'C') {\n            if (diff != 4)\n                return;\n        }\n        else if (answers[9] == 'D') {\n            if (diff != 1)\n                return;\n        }\n        else {\n            static_assert(true, \"should not reach here\");\n        }\n        // Finally, we got the unique solution and print it\n        std::cout << \"Finally we got the unqiue solution:\\n\";\n        for (auto x : answers) {\n            std::cout << x;\n        }\n        std::cout << \"\\n\";\n        return;\n    }\n    for (char i = 0; i < 4; i++) {\n        answers[problemCnt] = i + 'A';\n        enumerateing(problemCnt + 1);\n    }\n}\n \nint main() {\n    enumerateing(0);\n    getchar();\n    return 0;\n}\n```\n","slug":"inference","published":1,"updated":"2026-01-21T03:00:10.775Z","_id":"cmknfsoct00049dpxh977ejrf","comments":1,"photos":[],"content":"<p><img src=\"/../images/xztl.png\"><br>最近很火的刑侦推理题。。。我也是试了一下，答案是BCACA CDABA</p>\n<p>如果直接推理是很难的，但借助计算机可以暴力无脑出结果(因为总共只有4^9&#x3D;262144种情况)。具体做法是<br>1.首先生成所有可能的答案（递归生成解答树）<br>2.筛选掉不符合题目要求的（剪枝）<br>3.剩下唯一一个就是答案</p>\n<p>附source code:<a href=\"https://pastebin.com/2a17Eqwu\">https://pastebin.com/2a17Eqwu</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> answers[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Auxiliary functions</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMaxCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *std::<span class=\"built_in\">max_element</span>(abcd, abcd + <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMinCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *std::<span class=\"built_in\">min_element</span>(abcd, abcd + <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">sameWithProblem8</span><span class=\"params\">(<span class=\"type\">int</span> prob1, <span class=\"type\">int</span> probl2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> problem8Anaswer = answers[<span class=\"number\">7</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;A&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;B&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;C&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;D&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// BCACA CDABA</span></span><br><span class=\"line\"><span class=\"comment\">// All 4^9=262144 occurrences could be enumerated in the solution tree</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enumerateing</span><span class=\"params\">(<span class=\"type\">int</span> problemCnt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (problemCnt == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check 1</span></span><br><span class=\"line\">        pass;</span><br><span class=\"line\">        <span class=\"comment\">// Check 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 3</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">1</span>] || answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">1</span>] || answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">4</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] != answers[<span class=\"number\">6</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">8</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] != answers[<span class=\"number\">9</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should  not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 5</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 6</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">2</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">1</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">3</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">5</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Check 7</span></span><br><span class=\"line\">        <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span> whichCharMinCount = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> min = abcd[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt; <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (abcd[k] &lt; min) &#123;</span><br><span class=\"line\">                min = abcd[k];</span><br><span class=\"line\">                whichCharMinCount = <span class=\"string\">&#x27;A&#x27;</span> + k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 8</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> nearProblem1 = [=](<span class=\"type\">int</span> prob1)-&gt;<span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> problem1Answer = answers[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[prob1 - <span class=\"number\">1</span>] - <span class=\"number\">1</span>) == problem1Answer || (answers[prob1 - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) == problem1Answer)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">7</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 9</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">5</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">9</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">9</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">1</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">8</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">8</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Check 10</span></span><br><span class=\"line\">        <span class=\"type\">int</span> diff = <span class=\"built_in\">findMaxCount</span>() - <span class=\"built_in\">findMinCount</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">3</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">4</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Finally, we got the unique solution and print it</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Finally we got the unqiue solution:\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : answers) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        answers[problemCnt] = i + <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">enumerateing</span>(problemCnt + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">enumerateing</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p><img src=\"/../images/xztl.png\"><br>最近很火的刑侦推理题。。。我也是试了一下，答案是BCACA CDABA</p>\n<p>如果直接推理是很难的，但借助计算机可以暴力无脑出结果(因为总共只有4^9&#x3D;262144种情况)。具体做法是<br>1.首先生成所有可能的答案（递归生成解答树）<br>2.筛选掉不符合题目要求的（剪枝）<br>3.剩下唯一一个就是答案</p>\n<p>附source code:<a href=\"https://pastebin.com/2a17Eqwu\">https://pastebin.com/2a17Eqwu</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> answers[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Auxiliary functions</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMaxCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *std::<span class=\"built_in\">max_element</span>(abcd, abcd + <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMinCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *std::<span class=\"built_in\">min_element</span>(abcd, abcd + <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">sameWithProblem8</span><span class=\"params\">(<span class=\"type\">int</span> prob1, <span class=\"type\">int</span> probl2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> problem8Anaswer = answers[<span class=\"number\">7</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;A&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;B&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;C&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (problem8Anaswer == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[prob1 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;D&#x27;</span> || answers[probl2 - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// BCACA CDABA</span></span><br><span class=\"line\"><span class=\"comment\">// All 4^9=262144 occurrences could be enumerated in the solution tree</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enumerateing</span><span class=\"params\">(<span class=\"type\">int</span> problemCnt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (problemCnt == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check 1</span></span><br><span class=\"line\">        pass;</span><br><span class=\"line\">        <span class=\"comment\">// Check 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 3</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">1</span>] || answers[<span class=\"number\">2</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">1</span>] || answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">3</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">2</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">2</span>] || answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">5</span>] || answers[<span class=\"number\">3</span>] == answers[<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">4</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">1</span>] != answers[<span class=\"number\">6</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">8</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] != answers[<span class=\"number\">9</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should  not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 5</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">3</span>] != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">4</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 6</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">2</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">1</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">3</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">5</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">sameWithProblem8</span>(<span class=\"number\">5</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Check 7</span></span><br><span class=\"line\">        <span class=\"type\">int</span> abcd[<span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            abcd[answers[i] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span> whichCharMinCount = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> min = abcd[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt; <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (abcd[k] &lt; min) &#123;</span><br><span class=\"line\">                min = abcd[k];</span><br><span class=\"line\">                whichCharMinCount = <span class=\"string\">&#x27;A&#x27;</span> + k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">6</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (whichCharMinCount != <span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 8</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> nearProblem1 = [=](<span class=\"type\">int</span> prob1)-&gt;<span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> problem1Answer = answers[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[prob1 - <span class=\"number\">1</span>] - <span class=\"number\">1</span>) == problem1Answer || (answers[prob1 - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) == problem1Answer)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">7</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">7</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">nearProblem1</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Check 9</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">5</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">5</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">9</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">9</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">1</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">1</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">8</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((answers[<span class=\"number\">0</span>] == answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">8</span>] == answers[<span class=\"number\">4</span>]) ||</span><br><span class=\"line\">                (answers[<span class=\"number\">0</span>] != answers[<span class=\"number\">5</span>] &amp;&amp; answers[<span class=\"number\">8</span>] != answers[<span class=\"number\">4</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Check 10</span></span><br><span class=\"line\">        <span class=\"type\">int</span> diff = <span class=\"built_in\">findMaxCount</span>() - <span class=\"built_in\">findMinCount</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">3</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;B&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">4</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (answers[<span class=\"number\">9</span>] == <span class=\"string\">&#x27;D&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff != <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;should not reach here&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Finally, we got the unique solution and print it</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Finally we got the unqiue solution:\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : answers) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        answers[problemCnt] = i + <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">enumerateing</span>(problemCnt + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">enumerateing</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Sparse Conditional Constant Propagation in Golang","date":"2023-05-26T16:00:00.000Z","_content":"\n### Introduction\n\nRecently, I implemented [Sparse Conditional Constant Propagation(SCCP)](https://github.com/golang/go/commit/4ee1d542eda8d8aab7ca2024a4a0a9068d3cad70) in Golang.\n\nSCCP is an old but useful optimization, the detailed algorithm was described in [Mark N. Wegman, F. Kenneth Zadeck: Constant Propagation with Conditional Branches TOPLAS 1991](https://www.cs.wustl.edu/~cytron/531Pages/f11/Resources/Papers/cprop.pdf).\n\nThis algorithm uses three level lattice for SSA value\n\n```\n      Top        undefined\n     / | \\\n .. 1  2  3 ..   constant\n     \\ | /\n     Bottom      not constant\n```\n\nIt starts with optimistically assuming that all SSA values are initially Top and then propagates constant facts only along reachable control flow paths Since some basic blocks are not visited yet, corresponding inputs of phi become Top, we use the `meet(phi)` to compute its lattice.\n\n```\n    Top ∩ any = any\n    Bottom ∩ any = Bottom\n    ConstantA ∩ ConstantA = ConstantA\n    ConstantA ∩ ConstantB = Bottom\n```\n\nEach lattice value is lowered most twice(Top to Constant, Constant to Bottom) due to lattice depth, resulting in a fast convergence speed of the algorithm.\n\n### SCCP Example\n\nThe following is a typical example that demonstrates the benefits of SCCP compared to various optimization combinations:\n\n```go\n//go:noinline\nfunc dummy() {}\n\n//go:noinline\nfunc tt() {\n\tfor i := int64(0); i >= 128; i++ {\n\t\tdummy()\n\t}\n}\n```\n\nThe corresponding SSA is as follows:\n\n```\nb1:\nv1 (?) = InitMem <mem>\nv4 (?) = Const64 <int64> [0] (i[int64])\nv6 (?) = Const64 <int64> [128]\nv12 (?) = Const64 <int64> [1]\nPlain → b2 (+91)\n\nb2: ← b1 b4\nv5 (91) = Phi <int64> v4 v13 (i[int64])\nv16 (94) = Phi <mem> v1 v10\nv7 (+91) = Leq64 <bool> v6 v5\nIf v7 → b4 b5 (likely) (91)\n\nb4: ← b2\nv9 (+92) = StaticCall <mem> {AuxCall{main.dummy}} v16\nv10 (92) = SelectN <mem> [0] v9\nv13 (+91) = Add64 <int64> v5 v12 (i[int64])\nPlain → b2 (91)\n\nb5: ← b2\nv14 (+94) = MakeResult <mem> v16\nRet v14 (94)\n```\n\nInitially, SCCP propagates constants along b1->b2. When it encounters `v5#Phi`, it optimistically assumes that the lattice of v13, which is the second parameter of the Phi and has not been visited in basic block b4, is Top. It calculates a constant lattice of value 0 for `v5 = Phi(Const,Top)`. Then, `v7 (+91) = Leq64 <bool> v6 v5(128 <= 0)` evaluates to false and is used as the control value to determine subsequent control flow, so only b2->b5 is propagated. Finally, the control flow ends. The transformed SSA is as follows:\n```\nb5:\nv1 (?) = InitMem <mem>\nv14 (+94) = MakeResult <mem> v1\nRet v14 (94)\n```\nThe entire loop is removed. In this way, SCCP can discover optimization opportunities that cannot be found by just combining constant folding and constant propagation and dead code elimination separately.\n\nThis advantage is usually manifested when code involves loops. Because loops have back edges, which often produce uncertain Phi values that are difficult to prove as constants in other optimizations, SCCP can take advantage of this. According to the aforementioned rules, SCCP simulates execution along the control flow and when it encounters a Phi, it can optimistically assume that the Phi is a constant and continue propagating constant facts along the control flow based on this assumption.\n\n### Performance evaluation\nIn practice, when to run SCCP is also something worth considering. Running SCCP optimization in the early stages of compilation can identify more constants, eliminate more dead code, and fold more constant calculations. Running SCCP in the later stages of compilation can discover optimization opportunities that were not found by earlier optimizations. We compared the performance of running SCCP at different critical stages:\n\n| Placement | Constant | Deadcode |\n| --------- | -------- | -------- |\n| before early deadcode | 451088 | 96553 |\n| before pre-opt deadcode | 329419 | 116650 |\n| before opt deadcode | 6078 | 765 |\n| before gcse deadcode | 3539 | 763 |\n| before generic deadcode | 2735 | 545 |\n| before lower | 2444 | 535 |\n\nI conservatively propose to only place SCCP before `generic deadcode`. Ideally I think it should be performed both before `generic deadcode` and before `early deadcode`\n\n## Future work\nThere is still a lot of work to be done in the future, and here are some that come to my mind at the moment (in order of difficulty):\n\n- Support more basic constant types, such as OpConstNil, OpConstString\n- Support constant folding for more operations\n- Extend the constant lattice, implement value range propagation, at least achieving what prove pass can currently do, and eventually removing prove pass.\n- Support interprocedural SCCP that awares of function invocations.","source":"_posts/golang-sccp.md","raw":"---\nlayout: post\ntitle:  \"Sparse Conditional Constant Propagation in Golang\"\ndate:   2023-05-27\ncategories: [Compiler, Golang]\n---\n\n### Introduction\n\nRecently, I implemented [Sparse Conditional Constant Propagation(SCCP)](https://github.com/golang/go/commit/4ee1d542eda8d8aab7ca2024a4a0a9068d3cad70) in Golang.\n\nSCCP is an old but useful optimization, the detailed algorithm was described in [Mark N. Wegman, F. Kenneth Zadeck: Constant Propagation with Conditional Branches TOPLAS 1991](https://www.cs.wustl.edu/~cytron/531Pages/f11/Resources/Papers/cprop.pdf).\n\nThis algorithm uses three level lattice for SSA value\n\n```\n      Top        undefined\n     / | \\\n .. 1  2  3 ..   constant\n     \\ | /\n     Bottom      not constant\n```\n\nIt starts with optimistically assuming that all SSA values are initially Top and then propagates constant facts only along reachable control flow paths Since some basic blocks are not visited yet, corresponding inputs of phi become Top, we use the `meet(phi)` to compute its lattice.\n\n```\n    Top ∩ any = any\n    Bottom ∩ any = Bottom\n    ConstantA ∩ ConstantA = ConstantA\n    ConstantA ∩ ConstantB = Bottom\n```\n\nEach lattice value is lowered most twice(Top to Constant, Constant to Bottom) due to lattice depth, resulting in a fast convergence speed of the algorithm.\n\n### SCCP Example\n\nThe following is a typical example that demonstrates the benefits of SCCP compared to various optimization combinations:\n\n```go\n//go:noinline\nfunc dummy() {}\n\n//go:noinline\nfunc tt() {\n\tfor i := int64(0); i >= 128; i++ {\n\t\tdummy()\n\t}\n}\n```\n\nThe corresponding SSA is as follows:\n\n```\nb1:\nv1 (?) = InitMem <mem>\nv4 (?) = Const64 <int64> [0] (i[int64])\nv6 (?) = Const64 <int64> [128]\nv12 (?) = Const64 <int64> [1]\nPlain → b2 (+91)\n\nb2: ← b1 b4\nv5 (91) = Phi <int64> v4 v13 (i[int64])\nv16 (94) = Phi <mem> v1 v10\nv7 (+91) = Leq64 <bool> v6 v5\nIf v7 → b4 b5 (likely) (91)\n\nb4: ← b2\nv9 (+92) = StaticCall <mem> {AuxCall{main.dummy}} v16\nv10 (92) = SelectN <mem> [0] v9\nv13 (+91) = Add64 <int64> v5 v12 (i[int64])\nPlain → b2 (91)\n\nb5: ← b2\nv14 (+94) = MakeResult <mem> v16\nRet v14 (94)\n```\n\nInitially, SCCP propagates constants along b1->b2. When it encounters `v5#Phi`, it optimistically assumes that the lattice of v13, which is the second parameter of the Phi and has not been visited in basic block b4, is Top. It calculates a constant lattice of value 0 for `v5 = Phi(Const,Top)`. Then, `v7 (+91) = Leq64 <bool> v6 v5(128 <= 0)` evaluates to false and is used as the control value to determine subsequent control flow, so only b2->b5 is propagated. Finally, the control flow ends. The transformed SSA is as follows:\n```\nb5:\nv1 (?) = InitMem <mem>\nv14 (+94) = MakeResult <mem> v1\nRet v14 (94)\n```\nThe entire loop is removed. In this way, SCCP can discover optimization opportunities that cannot be found by just combining constant folding and constant propagation and dead code elimination separately.\n\nThis advantage is usually manifested when code involves loops. Because loops have back edges, which often produce uncertain Phi values that are difficult to prove as constants in other optimizations, SCCP can take advantage of this. According to the aforementioned rules, SCCP simulates execution along the control flow and when it encounters a Phi, it can optimistically assume that the Phi is a constant and continue propagating constant facts along the control flow based on this assumption.\n\n### Performance evaluation\nIn practice, when to run SCCP is also something worth considering. Running SCCP optimization in the early stages of compilation can identify more constants, eliminate more dead code, and fold more constant calculations. Running SCCP in the later stages of compilation can discover optimization opportunities that were not found by earlier optimizations. We compared the performance of running SCCP at different critical stages:\n\n| Placement | Constant | Deadcode |\n| --------- | -------- | -------- |\n| before early deadcode | 451088 | 96553 |\n| before pre-opt deadcode | 329419 | 116650 |\n| before opt deadcode | 6078 | 765 |\n| before gcse deadcode | 3539 | 763 |\n| before generic deadcode | 2735 | 545 |\n| before lower | 2444 | 535 |\n\nI conservatively propose to only place SCCP before `generic deadcode`. Ideally I think it should be performed both before `generic deadcode` and before `early deadcode`\n\n## Future work\nThere is still a lot of work to be done in the future, and here are some that come to my mind at the moment (in order of difficulty):\n\n- Support more basic constant types, such as OpConstNil, OpConstString\n- Support constant folding for more operations\n- Extend the constant lattice, implement value range propagation, at least achieving what prove pass can currently do, and eventually removing prove pass.\n- Support interprocedural SCCP that awares of function invocations.","slug":"golang-sccp","published":1,"updated":"2026-01-21T03:09:11.496Z","_id":"cmknft1w300069dpxdmbtcxml","comments":1,"photos":[],"content":"<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Recently, I implemented <a href=\"https://github.com/golang/go/commit/4ee1d542eda8d8aab7ca2024a4a0a9068d3cad70\">Sparse Conditional Constant Propagation(SCCP)</a> in Golang.</p>\n<p>SCCP is an old but useful optimization, the detailed algorithm was described in <a href=\"https://www.cs.wustl.edu/~cytron/531Pages/f11/Resources/Papers/cprop.pdf\">Mark N. Wegman, F. Kenneth Zadeck: Constant Propagation with Conditional Branches TOPLAS 1991</a>.</p>\n<p>This algorithm uses three level lattice for SSA value</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     Top        undefined</span><br><span class=\"line\">    / | \\</span><br><span class=\"line\">.. 1  2  3 ..   constant</span><br><span class=\"line\">    \\ | /</span><br><span class=\"line\">    Bottom      not constant</span><br></pre></td></tr></table></figure>\n\n<p>It starts with optimistically assuming that all SSA values are initially Top and then propagates constant facts only along reachable control flow paths Since some basic blocks are not visited yet, corresponding inputs of phi become Top, we use the <code>meet(phi)</code> to compute its lattice.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Top ∩ any = any</span><br><span class=\"line\">Bottom ∩ any = Bottom</span><br><span class=\"line\">ConstantA ∩ ConstantA = ConstantA</span><br><span class=\"line\">ConstantA ∩ ConstantB = Bottom</span><br></pre></td></tr></table></figure>\n\n<p>Each lattice value is lowered most twice(Top to Constant, Constant to Bottom) due to lattice depth, resulting in a fast convergence speed of the algorithm.</p>\n<h3 id=\"SCCP-Example\"><a href=\"#SCCP-Example\" class=\"headerlink\" title=\"SCCP Example\"></a>SCCP Example</h3><p>The following is a typical example that demonstrates the benefits of SCCP compared to various optimization combinations:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:noinline</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dummy</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:noinline</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tt</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"type\">int64</span>(<span class=\"number\">0</span>); i &gt;= <span class=\"number\">128</span>; i++ &#123;</span><br><span class=\"line\">\t\tdummy()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The corresponding SSA is as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1:</span><br><span class=\"line\">v1 (?) = InitMem &lt;mem&gt;</span><br><span class=\"line\">v4 (?) = Const64 &lt;int64&gt; [0] (i[int64])</span><br><span class=\"line\">v6 (?) = Const64 &lt;int64&gt; [128]</span><br><span class=\"line\">v12 (?) = Const64 &lt;int64&gt; [1]</span><br><span class=\"line\">Plain → b2 (+91)</span><br><span class=\"line\"></span><br><span class=\"line\">b2: ← b1 b4</span><br><span class=\"line\">v5 (91) = Phi &lt;int64&gt; v4 v13 (i[int64])</span><br><span class=\"line\">v16 (94) = Phi &lt;mem&gt; v1 v10</span><br><span class=\"line\">v7 (+91) = Leq64 &lt;bool&gt; v6 v5</span><br><span class=\"line\">If v7 → b4 b5 (likely) (91)</span><br><span class=\"line\"></span><br><span class=\"line\">b4: ← b2</span><br><span class=\"line\">v9 (+92) = StaticCall &lt;mem&gt; &#123;AuxCall&#123;main.dummy&#125;&#125; v16</span><br><span class=\"line\">v10 (92) = SelectN &lt;mem&gt; [0] v9</span><br><span class=\"line\">v13 (+91) = Add64 &lt;int64&gt; v5 v12 (i[int64])</span><br><span class=\"line\">Plain → b2 (91)</span><br><span class=\"line\"></span><br><span class=\"line\">b5: ← b2</span><br><span class=\"line\">v14 (+94) = MakeResult &lt;mem&gt; v16</span><br><span class=\"line\">Ret v14 (94)</span><br></pre></td></tr></table></figure>\n\n<p>Initially, SCCP propagates constants along b1-&gt;b2. When it encounters <code>v5#Phi</code>, it optimistically assumes that the lattice of v13, which is the second parameter of the Phi and has not been visited in basic block b4, is Top. It calculates a constant lattice of value 0 for <code>v5 = Phi(Const,Top)</code>. Then, <code>v7 (+91) = Leq64 &lt;bool&gt; v6 v5(128 &lt;= 0)</code> evaluates to false and is used as the control value to determine subsequent control flow, so only b2-&gt;b5 is propagated. Finally, the control flow ends. The transformed SSA is as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b5:</span><br><span class=\"line\">v1 (?) = InitMem &lt;mem&gt;</span><br><span class=\"line\">v14 (+94) = MakeResult &lt;mem&gt; v1</span><br><span class=\"line\">Ret v14 (94)</span><br></pre></td></tr></table></figure>\n<p>The entire loop is removed. In this way, SCCP can discover optimization opportunities that cannot be found by just combining constant folding and constant propagation and dead code elimination separately.</p>\n<p>This advantage is usually manifested when code involves loops. Because loops have back edges, which often produce uncertain Phi values that are difficult to prove as constants in other optimizations, SCCP can take advantage of this. According to the aforementioned rules, SCCP simulates execution along the control flow and when it encounters a Phi, it can optimistically assume that the Phi is a constant and continue propagating constant facts along the control flow based on this assumption.</p>\n<h3 id=\"Performance-evaluation\"><a href=\"#Performance-evaluation\" class=\"headerlink\" title=\"Performance evaluation\"></a>Performance evaluation</h3><p>In practice, when to run SCCP is also something worth considering. Running SCCP optimization in the early stages of compilation can identify more constants, eliminate more dead code, and fold more constant calculations. Running SCCP in the later stages of compilation can discover optimization opportunities that were not found by earlier optimizations. We compared the performance of running SCCP at different critical stages:</p>\n<table>\n<thead>\n<tr>\n<th>Placement</th>\n<th>Constant</th>\n<th>Deadcode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>before early deadcode</td>\n<td>451088</td>\n<td>96553</td>\n</tr>\n<tr>\n<td>before pre-opt deadcode</td>\n<td>329419</td>\n<td>116650</td>\n</tr>\n<tr>\n<td>before opt deadcode</td>\n<td>6078</td>\n<td>765</td>\n</tr>\n<tr>\n<td>before gcse deadcode</td>\n<td>3539</td>\n<td>763</td>\n</tr>\n<tr>\n<td>before generic deadcode</td>\n<td>2735</td>\n<td>545</td>\n</tr>\n<tr>\n<td>before lower</td>\n<td>2444</td>\n<td>535</td>\n</tr>\n</tbody></table>\n<p>I conservatively propose to only place SCCP before <code>generic deadcode</code>. Ideally I think it should be performed both before <code>generic deadcode</code> and before <code>early deadcode</code></p>\n<h2 id=\"Future-work\"><a href=\"#Future-work\" class=\"headerlink\" title=\"Future work\"></a>Future work</h2><p>There is still a lot of work to be done in the future, and here are some that come to my mind at the moment (in order of difficulty):</p>\n<ul>\n<li>Support more basic constant types, such as OpConstNil, OpConstString</li>\n<li>Support constant folding for more operations</li>\n<li>Extend the constant lattice, implement value range propagation, at least achieving what prove pass can currently do, and eventually removing prove pass.</li>\n<li>Support interprocedural SCCP that awares of function invocations.</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Recently, I implemented <a href=\"https://github.com/golang/go/commit/4ee1d542eda8d8aab7ca2024a4a0a9068d3cad70\">Sparse Conditional Constant Propagation(SCCP)</a> in Golang.</p>\n<p>SCCP is an old but useful optimization, the detailed algorithm was described in <a href=\"https://www.cs.wustl.edu/~cytron/531Pages/f11/Resources/Papers/cprop.pdf\">Mark N. Wegman, F. Kenneth Zadeck: Constant Propagation with Conditional Branches TOPLAS 1991</a>.</p>\n<p>This algorithm uses three level lattice for SSA value</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     Top        undefined</span><br><span class=\"line\">    / | \\</span><br><span class=\"line\">.. 1  2  3 ..   constant</span><br><span class=\"line\">    \\ | /</span><br><span class=\"line\">    Bottom      not constant</span><br></pre></td></tr></table></figure>\n\n<p>It starts with optimistically assuming that all SSA values are initially Top and then propagates constant facts only along reachable control flow paths Since some basic blocks are not visited yet, corresponding inputs of phi become Top, we use the <code>meet(phi)</code> to compute its lattice.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Top ∩ any = any</span><br><span class=\"line\">Bottom ∩ any = Bottom</span><br><span class=\"line\">ConstantA ∩ ConstantA = ConstantA</span><br><span class=\"line\">ConstantA ∩ ConstantB = Bottom</span><br></pre></td></tr></table></figure>\n\n<p>Each lattice value is lowered most twice(Top to Constant, Constant to Bottom) due to lattice depth, resulting in a fast convergence speed of the algorithm.</p>\n<h3 id=\"SCCP-Example\"><a href=\"#SCCP-Example\" class=\"headerlink\" title=\"SCCP Example\"></a>SCCP Example</h3><p>The following is a typical example that demonstrates the benefits of SCCP compared to various optimization combinations:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:noinline</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dummy</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:noinline</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tt</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"type\">int64</span>(<span class=\"number\">0</span>); i &gt;= <span class=\"number\">128</span>; i++ &#123;</span><br><span class=\"line\">\t\tdummy()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The corresponding SSA is as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1:</span><br><span class=\"line\">v1 (?) = InitMem &lt;mem&gt;</span><br><span class=\"line\">v4 (?) = Const64 &lt;int64&gt; [0] (i[int64])</span><br><span class=\"line\">v6 (?) = Const64 &lt;int64&gt; [128]</span><br><span class=\"line\">v12 (?) = Const64 &lt;int64&gt; [1]</span><br><span class=\"line\">Plain → b2 (+91)</span><br><span class=\"line\"></span><br><span class=\"line\">b2: ← b1 b4</span><br><span class=\"line\">v5 (91) = Phi &lt;int64&gt; v4 v13 (i[int64])</span><br><span class=\"line\">v16 (94) = Phi &lt;mem&gt; v1 v10</span><br><span class=\"line\">v7 (+91) = Leq64 &lt;bool&gt; v6 v5</span><br><span class=\"line\">If v7 → b4 b5 (likely) (91)</span><br><span class=\"line\"></span><br><span class=\"line\">b4: ← b2</span><br><span class=\"line\">v9 (+92) = StaticCall &lt;mem&gt; &#123;AuxCall&#123;main.dummy&#125;&#125; v16</span><br><span class=\"line\">v10 (92) = SelectN &lt;mem&gt; [0] v9</span><br><span class=\"line\">v13 (+91) = Add64 &lt;int64&gt; v5 v12 (i[int64])</span><br><span class=\"line\">Plain → b2 (91)</span><br><span class=\"line\"></span><br><span class=\"line\">b5: ← b2</span><br><span class=\"line\">v14 (+94) = MakeResult &lt;mem&gt; v16</span><br><span class=\"line\">Ret v14 (94)</span><br></pre></td></tr></table></figure>\n\n<p>Initially, SCCP propagates constants along b1-&gt;b2. When it encounters <code>v5#Phi</code>, it optimistically assumes that the lattice of v13, which is the second parameter of the Phi and has not been visited in basic block b4, is Top. It calculates a constant lattice of value 0 for <code>v5 = Phi(Const,Top)</code>. Then, <code>v7 (+91) = Leq64 &lt;bool&gt; v6 v5(128 &lt;= 0)</code> evaluates to false and is used as the control value to determine subsequent control flow, so only b2-&gt;b5 is propagated. Finally, the control flow ends. The transformed SSA is as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b5:</span><br><span class=\"line\">v1 (?) = InitMem &lt;mem&gt;</span><br><span class=\"line\">v14 (+94) = MakeResult &lt;mem&gt; v1</span><br><span class=\"line\">Ret v14 (94)</span><br></pre></td></tr></table></figure>\n<p>The entire loop is removed. In this way, SCCP can discover optimization opportunities that cannot be found by just combining constant folding and constant propagation and dead code elimination separately.</p>\n<p>This advantage is usually manifested when code involves loops. Because loops have back edges, which often produce uncertain Phi values that are difficult to prove as constants in other optimizations, SCCP can take advantage of this. According to the aforementioned rules, SCCP simulates execution along the control flow and when it encounters a Phi, it can optimistically assume that the Phi is a constant and continue propagating constant facts along the control flow based on this assumption.</p>\n<h3 id=\"Performance-evaluation\"><a href=\"#Performance-evaluation\" class=\"headerlink\" title=\"Performance evaluation\"></a>Performance evaluation</h3><p>In practice, when to run SCCP is also something worth considering. Running SCCP optimization in the early stages of compilation can identify more constants, eliminate more dead code, and fold more constant calculations. Running SCCP in the later stages of compilation can discover optimization opportunities that were not found by earlier optimizations. We compared the performance of running SCCP at different critical stages:</p>\n<table>\n<thead>\n<tr>\n<th>Placement</th>\n<th>Constant</th>\n<th>Deadcode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>before early deadcode</td>\n<td>451088</td>\n<td>96553</td>\n</tr>\n<tr>\n<td>before pre-opt deadcode</td>\n<td>329419</td>\n<td>116650</td>\n</tr>\n<tr>\n<td>before opt deadcode</td>\n<td>6078</td>\n<td>765</td>\n</tr>\n<tr>\n<td>before gcse deadcode</td>\n<td>3539</td>\n<td>763</td>\n</tr>\n<tr>\n<td>before generic deadcode</td>\n<td>2735</td>\n<td>545</td>\n</tr>\n<tr>\n<td>before lower</td>\n<td>2444</td>\n<td>535</td>\n</tr>\n</tbody></table>\n<p>I conservatively propose to only place SCCP before <code>generic deadcode</code>. Ideally I think it should be performed both before <code>generic deadcode</code> and before <code>early deadcode</code></p>\n<h2 id=\"Future-work\"><a href=\"#Future-work\" class=\"headerlink\" title=\"Future work\"></a>Future work</h2><p>There is still a lot of work to be done in the future, and here are some that come to my mind at the moment (in order of difficulty):</p>\n<ul>\n<li>Support more basic constant types, such as OpConstNil, OpConstString</li>\n<li>Support constant folding for more operations</li>\n<li>Extend the constant lattice, implement value range propagation, at least achieving what prove pass can currently do, and eventually removing prove pass.</li>\n<li>Support interprocedural SCCP that awares of function invocations.</li>\n</ul>\n"},{"layout":"post","title":"Two-phase Segmented Heap Dump for JVM","date":"2023-08-08T16:00:00.000Z","_content":"\n### Motivation\nRecently, I implemented [Two-phase Segmented Heap Dump](https://bugs.openjdk.org/browse/JDK-8313450) for JVM.\n\nDuring the heapdump, Java application must pause execution and wait for the VM to complete heapdump before resuming. this is a well-known pain. [JDK-8252842](https://bugs.openjdk.org/browse/JDK-8252842) have added parallel support to heapdump in an attempt to alleviate this pain. However, in that patch, all concurrent threads competitively write heap data to the same heap file, and more memory is required to maintain the concurrent buffer queue and related stuff. In experiments, we did not feel a significant performance improvement from that.\n\nThe minor-pause solution, which is presented in this article, is a two-phase segmented heap dump:\n\n- Phase one(STW): Concurrent threads directly write data to segmented heap files. This process must take place during STW, which is guaranteed by [safepoint](https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint). (**Application is paused**)\n- Phase two(Non STW): Multiple heap files are merged into a complete heap dump file. STW is not needed for this phase. (**Application is resumed**)\n\nNow concurrent worker threads are not required to maintain a buffer queue, which would result in more memory overhead, nor do they need to compete for locks. In this way, it significantly **reduces 71~83% application pause time**.\n\nThe changes in the overall design are as follows:\n\n![](../images/fig1.png)\n<p align=\"center\">Figure1. Before</p>\n\n![](../images/fig2.png)\n<p align=\"center\">Figure2. After</p>\n\n\n### Performance evaluation\n\n | Memory | NumThread | Compress | Phase 1 STW | Phase 2 Merge | Total   |\n | ------ | --------- | -------- | ----------- | ------------- | ------- |\n | 8g     | 1 T       | N        | 15.612      | 0             | 15.612  |\n | 8g     | 32 T      | N        | 2.561725    | 11.936275     | 14.498  |\n | 8g     | 32 T      | C1       | 2.3084878   | 11.8895122    | 14.198  |\n | 8g     | 32 T      | C2       | 10.9355128  | 10.9464872    | 21.882  |\n | 8g     | 96 T      | N        | 2.6790452   | 11.3329548    | 14.012  |\n | 8g     | 96 T      | C1       | 2.3044796   | 1.2845204     | 3.589   |\n | 8g     | 96 T      | C2       | 9.7585151   | 10.4604849    | 20.219  |\n | 16g    | 1 T       | N        | 26.278      | 0             | 26.278  |\n | 16g    | 32 T      | N        | 5.231374    | 21.185626     | 26.417  |\n | 16g    | 32 T      | C1       | 5.6946983   | 0.8433017     | 6.538   |\n | 16g    | 32 T      | C2       | 21.8211105  | 19.3118895    | 41.133  |\n | 16g    | 96 T      | N        | 6.2445556   | 20.8964444    | 27.141  |\n | 16g    | 96 T      | C1       | 4.6007096   | 1.6582904     | 6.259   |\n | 16g    | 96 T      | C2       | 19.2965783  | 19.7104217    | 39.007  |\n | 32g    | 1 T       | N        | 48.149      | 0             | 48.149  |\n | 32g    | 32 T      | N        | 10.7734677  | 50.8695323    | 61.643  |\n | 32g    | 32 T      | C1       | 10.1642097  | 0.7387903     | 10.903  |\n | 32g    | 32 T      | C2       | 43.8407607  | 44.3112393    | 88.152  |\n | 32g    | 96 T      | N        | 13.1522042  | 48.2797958    | 61.432  |\n | 32g    | 96 T      | C1       | 9.0954641   | 0.7895359     | 9.885   |\n | 32g    | 96 T      | C2       | 38.9900931  | 41.5839069    | 80.574  |\n | 64g    | 1 T       | N        | 100.583     | 0             | 100.583 |\n | 64g    | 32 T      | N        | 20.9233744  | 113.7776256   | 134.701 |\n | 64g    | 32 T      | C1       | 18.5023784  | 0.8556216     | 19.358  |\n | 64g    | 32 T      | C2       | 86.4748377  | 86.2321623    | 172.707 |\n | 64g    | 96 T      | N        | 26.7374116  | 99.3425884    | 126.08  |\n | 64g    | 96 T      | C1       | 16.8101551  | 1.1278449     | 17.938  |\n | 64g    | 96 T      | C2       | 80.1626621  | 88.8403379    | 169.003 |\n | 128g   | 1 T       | N        | 233.843     | 0             | 233.843 |\n | 128g   | 32 T      | N        | 72.9945768  | 134.0654232   | 207.06  |\n | 128g   | 32 T      | C1       | 36.399436   | 0.605564      | 37.005  |\n | 128g   | 32 T      | C2       | 172.8942958 | 221.1317042   | 394.026 |\n | 128g   | 96 T      | N        | 67.6815929  | 268.6634071   | 336.345 |\n | 128g   | 96 T      | C1       | 35.2457306  | 0.9842694     | 36.23   |\n | 128g   | 96 T      | C2       | 162.2924705 | 235.0995295   | 397.392 |\n\n<p align=\"center\">Table1. heap dump generation(full)</p>\n\n| Memory | NumThread | Phase 1 STW | Phase 2 Merge | Total   |\n| ------ | --------- | ----------- | ------------- | ------- |\n| 8g     | 1 T       | 15.612      | 0             | 15.612  |\n| 8g     | 32 T      | 2.561725    | 11.936275     | 14.498  |\n| 8g     | 96 T      | 2.6790452   | 11.3329548    | 14.012  |\n| 16g    | 1 T       | 26.278      | 0             | 26.278  |\n| 16g    | 32 T      | 5.231374    | 21.185626     | 26.417  |\n| 16g    | 96 T      | 6.2445556   | 20.8964444    | 27.141  |\n| 32g    | 1 T       | 48.149      | 0             | 48.149  |\n| 32g    | 32 T      | 10.7734677  | 50.8695323    | 61.643  |\n| 32g    | 96 T      | 13.1522042  | 48.2797958    | 61.432  |\n| 64g    | 1 T       | 100.583     | 0             | 100.583 |\n| 64g    | 32 T      | 20.9233744  | 113.7776256   | 134.701 |\n| 64g    | 96 T      | 26.7374116  | 99.3425884    | 126.08  |\n| 128g   | 1 T       | 233.843     | 0             | 233.843 |\n| 128g   | 32 T      | 72.9945768  | 134.0654232   | 207.06  |\n| 128g   | 96 T      | 67.6815929  | 268.6634071   | 336.345 |\n\n<p align=\"center\">Table2. heap dump generation(w/o compression)</p>\n\n> N.B. all compression benchmark data are based on -gz=9, i.e. strongest compression\n> - *N* means no compression\n> - *C1* means all objects are byte[] in heap and they are all empty\n> - *C2* means all objects are byte[] in heap and they are full of random data\n> - For parallel dump, *Total* = *Phase 1 STW* + *Phase 2 Merge*.\n> - For serial dump, *Total* = *Phase 1 STW*\n\n![image](../images/fig3.jpg)\n\n<p align=\"center\">Figure3. heap dump generation(full)</p>\n\n![image](../images/fig4.jpg)\n<p align=\"center\">Figure4. heap dump generation(w/o compression)</p>\n\nWhen compression is enabled, STW/Total time heavily depends on the sparseness of the application heap. If the heap is full of compressible objects(e.g. all objects are empty byte array), Total ≈ STW, merge process is incredibly fast. If the heap data is not suitable for compression(e.g. all objects are full of random data), the STW reduction is not appealing, the total dump time is also increased.\n\n### User Perspective\nWhen executing commands such as `jmap` or `jcmd GC.heap_dump` to initiate the heapdump, the VM intelligently selects an appropriate number of parallel threads based on various factors. These factors include the type of garbage collector in use, the number of processors available, the heap size, and the degree of fragmentation. By considering these factors, the VM strives to perform the heapdump in parallel whenever feasible.\n\nIn cases where parallel heapdump is not possible due to certain constraints, the VM gracefully falls back to using a single thread for the heapdump process. In such scenarios, the heapdump behavior remains consistent with the previous approach. To gain more insights into the heapdump process, the `-Xlog:heapdump` option can be utilized to observe and analyze the details of the heapdump.\n\n### Conclusion\nOverall, the introduction of the two-phase approach effectively reduces the application pause time during the heapdump process, it is important to note that the total time required for the heapdump itself __may__ slightly increase. However, considering the reduction of STW time, I think it is an acceptable trade-off. This optimization solely focuses on minimizing the impact on the application pause time, there is still room for optimization in the second merge phase.\n","source":"_posts/two-phase-segmented-heapdump.md","raw":"---\nlayout: post\ntitle:  \"Two-phase Segmented Heap Dump for JVM\"\ndate:   2023-08-09\ncategories: [JVM]\n---\n\n### Motivation\nRecently, I implemented [Two-phase Segmented Heap Dump](https://bugs.openjdk.org/browse/JDK-8313450) for JVM.\n\nDuring the heapdump, Java application must pause execution and wait for the VM to complete heapdump before resuming. this is a well-known pain. [JDK-8252842](https://bugs.openjdk.org/browse/JDK-8252842) have added parallel support to heapdump in an attempt to alleviate this pain. However, in that patch, all concurrent threads competitively write heap data to the same heap file, and more memory is required to maintain the concurrent buffer queue and related stuff. In experiments, we did not feel a significant performance improvement from that.\n\nThe minor-pause solution, which is presented in this article, is a two-phase segmented heap dump:\n\n- Phase one(STW): Concurrent threads directly write data to segmented heap files. This process must take place during STW, which is guaranteed by [safepoint](https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint). (**Application is paused**)\n- Phase two(Non STW): Multiple heap files are merged into a complete heap dump file. STW is not needed for this phase. (**Application is resumed**)\n\nNow concurrent worker threads are not required to maintain a buffer queue, which would result in more memory overhead, nor do they need to compete for locks. In this way, it significantly **reduces 71~83% application pause time**.\n\nThe changes in the overall design are as follows:\n\n![](../images/fig1.png)\n<p align=\"center\">Figure1. Before</p>\n\n![](../images/fig2.png)\n<p align=\"center\">Figure2. After</p>\n\n\n### Performance evaluation\n\n | Memory | NumThread | Compress | Phase 1 STW | Phase 2 Merge | Total   |\n | ------ | --------- | -------- | ----------- | ------------- | ------- |\n | 8g     | 1 T       | N        | 15.612      | 0             | 15.612  |\n | 8g     | 32 T      | N        | 2.561725    | 11.936275     | 14.498  |\n | 8g     | 32 T      | C1       | 2.3084878   | 11.8895122    | 14.198  |\n | 8g     | 32 T      | C2       | 10.9355128  | 10.9464872    | 21.882  |\n | 8g     | 96 T      | N        | 2.6790452   | 11.3329548    | 14.012  |\n | 8g     | 96 T      | C1       | 2.3044796   | 1.2845204     | 3.589   |\n | 8g     | 96 T      | C2       | 9.7585151   | 10.4604849    | 20.219  |\n | 16g    | 1 T       | N        | 26.278      | 0             | 26.278  |\n | 16g    | 32 T      | N        | 5.231374    | 21.185626     | 26.417  |\n | 16g    | 32 T      | C1       | 5.6946983   | 0.8433017     | 6.538   |\n | 16g    | 32 T      | C2       | 21.8211105  | 19.3118895    | 41.133  |\n | 16g    | 96 T      | N        | 6.2445556   | 20.8964444    | 27.141  |\n | 16g    | 96 T      | C1       | 4.6007096   | 1.6582904     | 6.259   |\n | 16g    | 96 T      | C2       | 19.2965783  | 19.7104217    | 39.007  |\n | 32g    | 1 T       | N        | 48.149      | 0             | 48.149  |\n | 32g    | 32 T      | N        | 10.7734677  | 50.8695323    | 61.643  |\n | 32g    | 32 T      | C1       | 10.1642097  | 0.7387903     | 10.903  |\n | 32g    | 32 T      | C2       | 43.8407607  | 44.3112393    | 88.152  |\n | 32g    | 96 T      | N        | 13.1522042  | 48.2797958    | 61.432  |\n | 32g    | 96 T      | C1       | 9.0954641   | 0.7895359     | 9.885   |\n | 32g    | 96 T      | C2       | 38.9900931  | 41.5839069    | 80.574  |\n | 64g    | 1 T       | N        | 100.583     | 0             | 100.583 |\n | 64g    | 32 T      | N        | 20.9233744  | 113.7776256   | 134.701 |\n | 64g    | 32 T      | C1       | 18.5023784  | 0.8556216     | 19.358  |\n | 64g    | 32 T      | C2       | 86.4748377  | 86.2321623    | 172.707 |\n | 64g    | 96 T      | N        | 26.7374116  | 99.3425884    | 126.08  |\n | 64g    | 96 T      | C1       | 16.8101551  | 1.1278449     | 17.938  |\n | 64g    | 96 T      | C2       | 80.1626621  | 88.8403379    | 169.003 |\n | 128g   | 1 T       | N        | 233.843     | 0             | 233.843 |\n | 128g   | 32 T      | N        | 72.9945768  | 134.0654232   | 207.06  |\n | 128g   | 32 T      | C1       | 36.399436   | 0.605564      | 37.005  |\n | 128g   | 32 T      | C2       | 172.8942958 | 221.1317042   | 394.026 |\n | 128g   | 96 T      | N        | 67.6815929  | 268.6634071   | 336.345 |\n | 128g   | 96 T      | C1       | 35.2457306  | 0.9842694     | 36.23   |\n | 128g   | 96 T      | C2       | 162.2924705 | 235.0995295   | 397.392 |\n\n<p align=\"center\">Table1. heap dump generation(full)</p>\n\n| Memory | NumThread | Phase 1 STW | Phase 2 Merge | Total   |\n| ------ | --------- | ----------- | ------------- | ------- |\n| 8g     | 1 T       | 15.612      | 0             | 15.612  |\n| 8g     | 32 T      | 2.561725    | 11.936275     | 14.498  |\n| 8g     | 96 T      | 2.6790452   | 11.3329548    | 14.012  |\n| 16g    | 1 T       | 26.278      | 0             | 26.278  |\n| 16g    | 32 T      | 5.231374    | 21.185626     | 26.417  |\n| 16g    | 96 T      | 6.2445556   | 20.8964444    | 27.141  |\n| 32g    | 1 T       | 48.149      | 0             | 48.149  |\n| 32g    | 32 T      | 10.7734677  | 50.8695323    | 61.643  |\n| 32g    | 96 T      | 13.1522042  | 48.2797958    | 61.432  |\n| 64g    | 1 T       | 100.583     | 0             | 100.583 |\n| 64g    | 32 T      | 20.9233744  | 113.7776256   | 134.701 |\n| 64g    | 96 T      | 26.7374116  | 99.3425884    | 126.08  |\n| 128g   | 1 T       | 233.843     | 0             | 233.843 |\n| 128g   | 32 T      | 72.9945768  | 134.0654232   | 207.06  |\n| 128g   | 96 T      | 67.6815929  | 268.6634071   | 336.345 |\n\n<p align=\"center\">Table2. heap dump generation(w/o compression)</p>\n\n> N.B. all compression benchmark data are based on -gz=9, i.e. strongest compression\n> - *N* means no compression\n> - *C1* means all objects are byte[] in heap and they are all empty\n> - *C2* means all objects are byte[] in heap and they are full of random data\n> - For parallel dump, *Total* = *Phase 1 STW* + *Phase 2 Merge*.\n> - For serial dump, *Total* = *Phase 1 STW*\n\n![image](../images/fig3.jpg)\n\n<p align=\"center\">Figure3. heap dump generation(full)</p>\n\n![image](../images/fig4.jpg)\n<p align=\"center\">Figure4. heap dump generation(w/o compression)</p>\n\nWhen compression is enabled, STW/Total time heavily depends on the sparseness of the application heap. If the heap is full of compressible objects(e.g. all objects are empty byte array), Total ≈ STW, merge process is incredibly fast. If the heap data is not suitable for compression(e.g. all objects are full of random data), the STW reduction is not appealing, the total dump time is also increased.\n\n### User Perspective\nWhen executing commands such as `jmap` or `jcmd GC.heap_dump` to initiate the heapdump, the VM intelligently selects an appropriate number of parallel threads based on various factors. These factors include the type of garbage collector in use, the number of processors available, the heap size, and the degree of fragmentation. By considering these factors, the VM strives to perform the heapdump in parallel whenever feasible.\n\nIn cases where parallel heapdump is not possible due to certain constraints, the VM gracefully falls back to using a single thread for the heapdump process. In such scenarios, the heapdump behavior remains consistent with the previous approach. To gain more insights into the heapdump process, the `-Xlog:heapdump` option can be utilized to observe and analyze the details of the heapdump.\n\n### Conclusion\nOverall, the introduction of the two-phase approach effectively reduces the application pause time during the heapdump process, it is important to note that the total time required for the heapdump itself __may__ slightly increase. However, considering the reduction of STW time, I think it is an acceptable trade-off. This optimization solely focuses on minimizing the impact on the application pause time, there is still room for optimization in the second merge phase.\n","slug":"two-phase-segmented-heapdump","published":1,"updated":"2026-01-21T03:12:21.469Z","_id":"cmkng4hxj000034pxfau714m9","comments":1,"photos":[],"content":"<h3 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h3><p>Recently, I implemented <a href=\"https://bugs.openjdk.org/browse/JDK-8313450\">Two-phase Segmented Heap Dump</a> for JVM.</p>\n<p>During the heapdump, Java application must pause execution and wait for the VM to complete heapdump before resuming. this is a well-known pain. <a href=\"https://bugs.openjdk.org/browse/JDK-8252842\">JDK-8252842</a> have added parallel support to heapdump in an attempt to alleviate this pain. However, in that patch, all concurrent threads competitively write heap data to the same heap file, and more memory is required to maintain the concurrent buffer queue and related stuff. In experiments, we did not feel a significant performance improvement from that.</p>\n<p>The minor-pause solution, which is presented in this article, is a two-phase segmented heap dump:</p>\n<ul>\n<li>Phase one(STW): Concurrent threads directly write data to segmented heap files. This process must take place during STW, which is guaranteed by <a href=\"https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint\">safepoint</a>. (<strong>Application is paused</strong>)</li>\n<li>Phase two(Non STW): Multiple heap files are merged into a complete heap dump file. STW is not needed for this phase. (<strong>Application is resumed</strong>)</li>\n</ul>\n<p>Now concurrent worker threads are not required to maintain a buffer queue, which would result in more memory overhead, nor do they need to compete for locks. In this way, it significantly <strong>reduces 71~83% application pause time</strong>.</p>\n<p>The changes in the overall design are as follows:</p>\n<p><img src=\"/../images/fig1.png\"></p>\n<p align=\"center\">Figure1. Before</p>\n\n<p><img src=\"/../images/fig2.png\"></p>\n<p align=\"center\">Figure2. After</p>\n\n\n<h3 id=\"Performance-evaluation\"><a href=\"#Performance-evaluation\" class=\"headerlink\" title=\"Performance evaluation\"></a>Performance evaluation</h3><table>\n<thead>\n<tr>\n<th>Memory</th>\n<th>NumThread</th>\n<th>Compress</th>\n<th>Phase 1 STW</th>\n<th>Phase 2 Merge</th>\n<th>Total</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8g</td>\n<td>1 T</td>\n<td>N</td>\n<td>15.612</td>\n<td>0</td>\n<td>15.612</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>N</td>\n<td>2.561725</td>\n<td>11.936275</td>\n<td>14.498</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>2.3084878</td>\n<td>11.8895122</td>\n<td>14.198</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>10.9355128</td>\n<td>10.9464872</td>\n<td>21.882</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>N</td>\n<td>2.6790452</td>\n<td>11.3329548</td>\n<td>14.012</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>2.3044796</td>\n<td>1.2845204</td>\n<td>3.589</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>9.7585151</td>\n<td>10.4604849</td>\n<td>20.219</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>1 T</td>\n<td>N</td>\n<td>26.278</td>\n<td>0</td>\n<td>26.278</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>N</td>\n<td>5.231374</td>\n<td>21.185626</td>\n<td>26.417</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>5.6946983</td>\n<td>0.8433017</td>\n<td>6.538</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>21.8211105</td>\n<td>19.3118895</td>\n<td>41.133</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>N</td>\n<td>6.2445556</td>\n<td>20.8964444</td>\n<td>27.141</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>4.6007096</td>\n<td>1.6582904</td>\n<td>6.259</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>19.2965783</td>\n<td>19.7104217</td>\n<td>39.007</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>1 T</td>\n<td>N</td>\n<td>48.149</td>\n<td>0</td>\n<td>48.149</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>N</td>\n<td>10.7734677</td>\n<td>50.8695323</td>\n<td>61.643</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>10.1642097</td>\n<td>0.7387903</td>\n<td>10.903</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>43.8407607</td>\n<td>44.3112393</td>\n<td>88.152</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>N</td>\n<td>13.1522042</td>\n<td>48.2797958</td>\n<td>61.432</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>9.0954641</td>\n<td>0.7895359</td>\n<td>9.885</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>38.9900931</td>\n<td>41.5839069</td>\n<td>80.574</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>1 T</td>\n<td>N</td>\n<td>100.583</td>\n<td>0</td>\n<td>100.583</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>N</td>\n<td>20.9233744</td>\n<td>113.7776256</td>\n<td>134.701</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>18.5023784</td>\n<td>0.8556216</td>\n<td>19.358</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>86.4748377</td>\n<td>86.2321623</td>\n<td>172.707</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>N</td>\n<td>26.7374116</td>\n<td>99.3425884</td>\n<td>126.08</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>16.8101551</td>\n<td>1.1278449</td>\n<td>17.938</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>80.1626621</td>\n<td>88.8403379</td>\n<td>169.003</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>1 T</td>\n<td>N</td>\n<td>233.843</td>\n<td>0</td>\n<td>233.843</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>N</td>\n<td>72.9945768</td>\n<td>134.0654232</td>\n<td>207.06</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>36.399436</td>\n<td>0.605564</td>\n<td>37.005</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>172.8942958</td>\n<td>221.1317042</td>\n<td>394.026</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>N</td>\n<td>67.6815929</td>\n<td>268.6634071</td>\n<td>336.345</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>35.2457306</td>\n<td>0.9842694</td>\n<td>36.23</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>162.2924705</td>\n<td>235.0995295</td>\n<td>397.392</td>\n</tr>\n</tbody></table>\n<p align=\"center\">Table1. heap dump generation(full)</p>\n\n<table>\n<thead>\n<tr>\n<th>Memory</th>\n<th>NumThread</th>\n<th>Phase 1 STW</th>\n<th>Phase 2 Merge</th>\n<th>Total</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8g</td>\n<td>1 T</td>\n<td>15.612</td>\n<td>0</td>\n<td>15.612</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>2.561725</td>\n<td>11.936275</td>\n<td>14.498</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>2.6790452</td>\n<td>11.3329548</td>\n<td>14.012</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>1 T</td>\n<td>26.278</td>\n<td>0</td>\n<td>26.278</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>5.231374</td>\n<td>21.185626</td>\n<td>26.417</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>6.2445556</td>\n<td>20.8964444</td>\n<td>27.141</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>1 T</td>\n<td>48.149</td>\n<td>0</td>\n<td>48.149</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>10.7734677</td>\n<td>50.8695323</td>\n<td>61.643</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>13.1522042</td>\n<td>48.2797958</td>\n<td>61.432</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>1 T</td>\n<td>100.583</td>\n<td>0</td>\n<td>100.583</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>20.9233744</td>\n<td>113.7776256</td>\n<td>134.701</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>26.7374116</td>\n<td>99.3425884</td>\n<td>126.08</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>1 T</td>\n<td>233.843</td>\n<td>0</td>\n<td>233.843</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>72.9945768</td>\n<td>134.0654232</td>\n<td>207.06</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>67.6815929</td>\n<td>268.6634071</td>\n<td>336.345</td>\n</tr>\n</tbody></table>\n<p align=\"center\">Table2. heap dump generation(w/o compression)</p>\n\n<blockquote>\n<p>N.B. all compression benchmark data are based on -gz&#x3D;9, i.e. strongest compression</p>\n<ul>\n<li><em>N</em> means no compression</li>\n<li><em>C1</em> means all objects are byte[] in heap and they are all empty</li>\n<li><em>C2</em> means all objects are byte[] in heap and they are full of random data</li>\n<li>For parallel dump, <em>Total</em> &#x3D; <em>Phase 1 STW</em> + <em>Phase 2 Merge</em>.</li>\n<li>For serial dump, <em>Total</em> &#x3D; <em>Phase 1 STW</em></li>\n</ul>\n</blockquote>\n<p><img src=\"/../images/fig3.jpg\" alt=\"image\"></p>\n<p align=\"center\">Figure3. heap dump generation(full)</p>\n\n<p><img src=\"/../images/fig4.jpg\" alt=\"image\"></p>\n<p align=\"center\">Figure4. heap dump generation(w/o compression)</p>\n\n<p>When compression is enabled, STW&#x2F;Total time heavily depends on the sparseness of the application heap. If the heap is full of compressible objects(e.g. all objects are empty byte array), Total ≈ STW, merge process is incredibly fast. If the heap data is not suitable for compression(e.g. all objects are full of random data), the STW reduction is not appealing, the total dump time is also increased.</p>\n<h3 id=\"User-Perspective\"><a href=\"#User-Perspective\" class=\"headerlink\" title=\"User Perspective\"></a>User Perspective</h3><p>When executing commands such as <code>jmap</code> or <code>jcmd GC.heap_dump</code> to initiate the heapdump, the VM intelligently selects an appropriate number of parallel threads based on various factors. These factors include the type of garbage collector in use, the number of processors available, the heap size, and the degree of fragmentation. By considering these factors, the VM strives to perform the heapdump in parallel whenever feasible.</p>\n<p>In cases where parallel heapdump is not possible due to certain constraints, the VM gracefully falls back to using a single thread for the heapdump process. In such scenarios, the heapdump behavior remains consistent with the previous approach. To gain more insights into the heapdump process, the <code>-Xlog:heapdump</code> option can be utilized to observe and analyze the details of the heapdump.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>Overall, the introduction of the two-phase approach effectively reduces the application pause time during the heapdump process, it is important to note that the total time required for the heapdump itself <strong>may</strong> slightly increase. However, considering the reduction of STW time, I think it is an acceptable trade-off. This optimization solely focuses on minimizing the impact on the application pause time, there is still room for optimization in the second merge phase.</p>\n","excerpt":"","more":"<h3 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h3><p>Recently, I implemented <a href=\"https://bugs.openjdk.org/browse/JDK-8313450\">Two-phase Segmented Heap Dump</a> for JVM.</p>\n<p>During the heapdump, Java application must pause execution and wait for the VM to complete heapdump before resuming. this is a well-known pain. <a href=\"https://bugs.openjdk.org/browse/JDK-8252842\">JDK-8252842</a> have added parallel support to heapdump in an attempt to alleviate this pain. However, in that patch, all concurrent threads competitively write heap data to the same heap file, and more memory is required to maintain the concurrent buffer queue and related stuff. In experiments, we did not feel a significant performance improvement from that.</p>\n<p>The minor-pause solution, which is presented in this article, is a two-phase segmented heap dump:</p>\n<ul>\n<li>Phase one(STW): Concurrent threads directly write data to segmented heap files. This process must take place during STW, which is guaranteed by <a href=\"https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint\">safepoint</a>. (<strong>Application is paused</strong>)</li>\n<li>Phase two(Non STW): Multiple heap files are merged into a complete heap dump file. STW is not needed for this phase. (<strong>Application is resumed</strong>)</li>\n</ul>\n<p>Now concurrent worker threads are not required to maintain a buffer queue, which would result in more memory overhead, nor do they need to compete for locks. In this way, it significantly <strong>reduces 71~83% application pause time</strong>.</p>\n<p>The changes in the overall design are as follows:</p>\n<p><img src=\"/../images/fig1.png\"></p>\n<p align=\"center\">Figure1. Before</p>\n\n<p><img src=\"/../images/fig2.png\"></p>\n<p align=\"center\">Figure2. After</p>\n\n\n<h3 id=\"Performance-evaluation\"><a href=\"#Performance-evaluation\" class=\"headerlink\" title=\"Performance evaluation\"></a>Performance evaluation</h3><table>\n<thead>\n<tr>\n<th>Memory</th>\n<th>NumThread</th>\n<th>Compress</th>\n<th>Phase 1 STW</th>\n<th>Phase 2 Merge</th>\n<th>Total</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8g</td>\n<td>1 T</td>\n<td>N</td>\n<td>15.612</td>\n<td>0</td>\n<td>15.612</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>N</td>\n<td>2.561725</td>\n<td>11.936275</td>\n<td>14.498</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>2.3084878</td>\n<td>11.8895122</td>\n<td>14.198</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>10.9355128</td>\n<td>10.9464872</td>\n<td>21.882</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>N</td>\n<td>2.6790452</td>\n<td>11.3329548</td>\n<td>14.012</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>2.3044796</td>\n<td>1.2845204</td>\n<td>3.589</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>9.7585151</td>\n<td>10.4604849</td>\n<td>20.219</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>1 T</td>\n<td>N</td>\n<td>26.278</td>\n<td>0</td>\n<td>26.278</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>N</td>\n<td>5.231374</td>\n<td>21.185626</td>\n<td>26.417</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>5.6946983</td>\n<td>0.8433017</td>\n<td>6.538</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>21.8211105</td>\n<td>19.3118895</td>\n<td>41.133</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>N</td>\n<td>6.2445556</td>\n<td>20.8964444</td>\n<td>27.141</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>4.6007096</td>\n<td>1.6582904</td>\n<td>6.259</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>19.2965783</td>\n<td>19.7104217</td>\n<td>39.007</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>1 T</td>\n<td>N</td>\n<td>48.149</td>\n<td>0</td>\n<td>48.149</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>N</td>\n<td>10.7734677</td>\n<td>50.8695323</td>\n<td>61.643</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>10.1642097</td>\n<td>0.7387903</td>\n<td>10.903</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>43.8407607</td>\n<td>44.3112393</td>\n<td>88.152</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>N</td>\n<td>13.1522042</td>\n<td>48.2797958</td>\n<td>61.432</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>9.0954641</td>\n<td>0.7895359</td>\n<td>9.885</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>38.9900931</td>\n<td>41.5839069</td>\n<td>80.574</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>1 T</td>\n<td>N</td>\n<td>100.583</td>\n<td>0</td>\n<td>100.583</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>N</td>\n<td>20.9233744</td>\n<td>113.7776256</td>\n<td>134.701</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>18.5023784</td>\n<td>0.8556216</td>\n<td>19.358</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>86.4748377</td>\n<td>86.2321623</td>\n<td>172.707</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>N</td>\n<td>26.7374116</td>\n<td>99.3425884</td>\n<td>126.08</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>16.8101551</td>\n<td>1.1278449</td>\n<td>17.938</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>80.1626621</td>\n<td>88.8403379</td>\n<td>169.003</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>1 T</td>\n<td>N</td>\n<td>233.843</td>\n<td>0</td>\n<td>233.843</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>N</td>\n<td>72.9945768</td>\n<td>134.0654232</td>\n<td>207.06</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>C1</td>\n<td>36.399436</td>\n<td>0.605564</td>\n<td>37.005</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>C2</td>\n<td>172.8942958</td>\n<td>221.1317042</td>\n<td>394.026</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>N</td>\n<td>67.6815929</td>\n<td>268.6634071</td>\n<td>336.345</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>C1</td>\n<td>35.2457306</td>\n<td>0.9842694</td>\n<td>36.23</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>C2</td>\n<td>162.2924705</td>\n<td>235.0995295</td>\n<td>397.392</td>\n</tr>\n</tbody></table>\n<p align=\"center\">Table1. heap dump generation(full)</p>\n\n<table>\n<thead>\n<tr>\n<th>Memory</th>\n<th>NumThread</th>\n<th>Phase 1 STW</th>\n<th>Phase 2 Merge</th>\n<th>Total</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8g</td>\n<td>1 T</td>\n<td>15.612</td>\n<td>0</td>\n<td>15.612</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>32 T</td>\n<td>2.561725</td>\n<td>11.936275</td>\n<td>14.498</td>\n</tr>\n<tr>\n<td>8g</td>\n<td>96 T</td>\n<td>2.6790452</td>\n<td>11.3329548</td>\n<td>14.012</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>1 T</td>\n<td>26.278</td>\n<td>0</td>\n<td>26.278</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>32 T</td>\n<td>5.231374</td>\n<td>21.185626</td>\n<td>26.417</td>\n</tr>\n<tr>\n<td>16g</td>\n<td>96 T</td>\n<td>6.2445556</td>\n<td>20.8964444</td>\n<td>27.141</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>1 T</td>\n<td>48.149</td>\n<td>0</td>\n<td>48.149</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>32 T</td>\n<td>10.7734677</td>\n<td>50.8695323</td>\n<td>61.643</td>\n</tr>\n<tr>\n<td>32g</td>\n<td>96 T</td>\n<td>13.1522042</td>\n<td>48.2797958</td>\n<td>61.432</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>1 T</td>\n<td>100.583</td>\n<td>0</td>\n<td>100.583</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>32 T</td>\n<td>20.9233744</td>\n<td>113.7776256</td>\n<td>134.701</td>\n</tr>\n<tr>\n<td>64g</td>\n<td>96 T</td>\n<td>26.7374116</td>\n<td>99.3425884</td>\n<td>126.08</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>1 T</td>\n<td>233.843</td>\n<td>0</td>\n<td>233.843</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>32 T</td>\n<td>72.9945768</td>\n<td>134.0654232</td>\n<td>207.06</td>\n</tr>\n<tr>\n<td>128g</td>\n<td>96 T</td>\n<td>67.6815929</td>\n<td>268.6634071</td>\n<td>336.345</td>\n</tr>\n</tbody></table>\n<p align=\"center\">Table2. heap dump generation(w/o compression)</p>\n\n<blockquote>\n<p>N.B. all compression benchmark data are based on -gz&#x3D;9, i.e. strongest compression</p>\n<ul>\n<li><em>N</em> means no compression</li>\n<li><em>C1</em> means all objects are byte[] in heap and they are all empty</li>\n<li><em>C2</em> means all objects are byte[] in heap and they are full of random data</li>\n<li>For parallel dump, <em>Total</em> &#x3D; <em>Phase 1 STW</em> + <em>Phase 2 Merge</em>.</li>\n<li>For serial dump, <em>Total</em> &#x3D; <em>Phase 1 STW</em></li>\n</ul>\n</blockquote>\n<p><img src=\"/../images/fig3.jpg\" alt=\"image\"></p>\n<p align=\"center\">Figure3. heap dump generation(full)</p>\n\n<p><img src=\"/../images/fig4.jpg\" alt=\"image\"></p>\n<p align=\"center\">Figure4. heap dump generation(w/o compression)</p>\n\n<p>When compression is enabled, STW&#x2F;Total time heavily depends on the sparseness of the application heap. If the heap is full of compressible objects(e.g. all objects are empty byte array), Total ≈ STW, merge process is incredibly fast. If the heap data is not suitable for compression(e.g. all objects are full of random data), the STW reduction is not appealing, the total dump time is also increased.</p>\n<h3 id=\"User-Perspective\"><a href=\"#User-Perspective\" class=\"headerlink\" title=\"User Perspective\"></a>User Perspective</h3><p>When executing commands such as <code>jmap</code> or <code>jcmd GC.heap_dump</code> to initiate the heapdump, the VM intelligently selects an appropriate number of parallel threads based on various factors. These factors include the type of garbage collector in use, the number of processors available, the heap size, and the degree of fragmentation. By considering these factors, the VM strives to perform the heapdump in parallel whenever feasible.</p>\n<p>In cases where parallel heapdump is not possible due to certain constraints, the VM gracefully falls back to using a single thread for the heapdump process. In such scenarios, the heapdump behavior remains consistent with the previous approach. To gain more insights into the heapdump process, the <code>-Xlog:heapdump</code> option can be utilized to observe and analyze the details of the heapdump.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>Overall, the introduction of the two-phase approach effectively reduces the application pause time during the heapdump process, it is important to note that the total time required for the heapdump itself <strong>may</strong> slightly increase. However, considering the reduction of STW time, I think it is an acceptable trade-off. This optimization solely focuses on minimizing the impact on the application pause time, there is still room for optimization in the second merge phase.</p>\n"},{"layout":"post","title":"Loop Invariant Code Motion in Golang","date":"2023-08-26T16:00:00.000Z","_content":"\nRecently, I proposed [Loop Invariant Code Motion(LICM)](https://github.com/golang/go/pull/64815) in Golang, this patch isn't in the main branch. I mainly wanted to share some details and the design thinking.\n\n----\n\n## 1. Loop Invariant Code Motion\nThe main idea behind LICM is to move loop invariant values outside of the loop\nso that they are only executed once, instead of being repeatedly executed with\neach iteration of the loop. In the context of LICM, if a loop invariant can be\nspeculatively executed, then it can be freely hoisted to the loop entry.\nHowever, if it cannot be speculatively executed, there is still a chance that\nit can be hoisted outside the loop under a few prerequisites:\n\n- `#1 Instruction is guaranteed to execute unconditionally`\n- `#2 Instruction does not access memory locations that may alias with other memory operations inside the loop`\n\nFor `#1`, this is guaranteed by loop rotation, where the loop is guaranteed to\nexecute at least once after rotation. But that's not the whole story. If the\ninstruction is guarded by a conditional expression (e.g., loading from a memory\naddress usually guarded by an IsInBound check), in this case, we try to hoist\nit only if the loop invariant dominates all loop exits, which implies that it\nwill be executed unconditionally as soon as it enters the loop.\nFor `#2`, we rely on a simple but efficient type-based alias analysis to know\nwhether two memory access instructions may access the same memory location.\n\n## 2. Type-based Alias Analysis\n**Type-based Alias Analysis(TBAA)** is described in Amer Diwan, Kathryn S. McKinley, J. Eliot B. Moss: Type-Based Alias Analysis. PLDI 1998\nTBAA relies on the fact that Golang is a type-safe language, i.e. different\npointer types cannot be converted to each other in Golang. Under assumption,\nTBAA attempts to identify whether two pointers may point to same memory based\non their type and value semantics. They can be summarized as follows rules:\n```\n  #0 unsafe pointer may aliases with anything even if their types are different\n  #1 a must aliases with b if a==b\n  #2 a.f aliases with b.g if f==g and a aliases with b\n  #3 a.f aliases with *b if they have same types\n  #4 a[i] aliases with *b if they have same types\n  #5 a.f never aliases with b[i]\n  #6 a[i] aliases with b[j] if a==b\n  #7 a aliases with b if they have same types\n```\n\n## 3. Loop Close SSA Form\n**Loop closed SSA form(LCSSA)** is a special form of SSA form, which is used to simplify\nloop optimization. It ensures that all values defined inside the loop are only\nused within loop. The transformation looks up loop uses outside the loop and\ninserts the appropriate \"proxy phi\" at the loop exit, after which the outside\nof the loop does not use the loop def directly but the proxy phi.\n```\n   loop header:                         loop header:\n   v3 = Phi(0, v4)                      v3 = Phi(0, v4)\n   If cond->loop latch,loop exit        If cond->loop latch,loop exit\n\n   loop latch:                          loop latch:\n   v4 = Add(v3, 1)                =>    v4 = Add(v3, 1)\n   Plain->loop header                   Plain->loop header\n\n   loop exit:                           loop exit:\n   v5 = Add(5, v3)                      v6 = Phi(v3)  <= Proxy Phi\n   Ret v18                              v5 = Add(5, v6)\n                                        Ret v18\n```\nPreviously, v5 used v3 directly, where v5 is in the loop exit which is outside\nthe loop. After LCSSA transformation, v5 uses v6, which in turn uses v3. Here,\nv6 is the proxy phi. In the context of LCSSA, we can consider the use block of\nv6 to be the loop header rather than the loop exit. This way, all values defined\nin the loop are loop \"closed\", i.e. only used within the loop.\n\nAny further changes to the loop definition only need to update the proxy phi,\nrather than iterating through all its uses and handling properties such as\nThis significantly simplifies implementation of **Loop Rotation**\n\n## 4. Loop Rotation\n### 4.1 CFG transformation\n**Loop rotation**, also known as **loop inversion**, it transforms while/for loop to\ndo-while style loop, e.g.\n\n```golang\n// Before\nfor i := 0; i < cnt; i++ {\n  ...\n}\n\n// After\nif 0 < cnt {\n  i := 0\n  do {\n    ...\n  } while(i < cnt)\n}\n```\nThe original natural loop is in form of below IR\n```\n       entry\n         │\n         │  ┌───loop latch\n         ▼  ▼       ▲\n    loop header     │\n         │  │       │\n         │  └──►loop body\n         ▼\n     loop exit\n```\nIn the terminology, loop entry dominates the entire loop, loop header contains\nthe loop conditional test, loop body refers to the code that is repeated, loop\nlatch contains the backedge to loop header, for simple loops, the loop body is\nequal to loop latch, and loop exit refers to the block that dominated by the\nentire loop.\n\nWe move the conditional test from loop header to loop latch, incoming backedge\nargument of conditional test should be updated as well otherwise we would lose\none update. Also note that any other uses of moved values should be updated\nbecause moved Values now live in loop latch and may no longer dominates their\nuses. At this point, loop latch determines whether loop continues or exits\nbased on rotated test.\n\n```\n      entry\n        │\n        │\n        ▼\n    loop header◄──┐\n        │         │\n        │         │\n        ▼         │\n    loop body     │\n        │         │\n        │         │\n        ▼         │\n    loop latch────┘\n        │\n        │\n        ▼\n    loop exit\n```\nNow loop header and loop body are executed unconditionally, this may changes\nprogram semantics while original program executes them only if test is okay.\nA so-called loop guard is inserted to ensure loop is executed at least once.\n\n```\n        entry\n          │\n          │\n          ▼\n   ┌──loop guard\n   │      │\n   │      │\n   │      ▼\n   │  loop header◄──┐\n   │      │         │\n   │      │         │\n   │      ▼         │\n   │  loop body     │\n   │      │         │\n   │      │         │\n   │      ▼         │\n   │  loop latch────┘\n   │      │\n   │      │\n   │      ▼\n   └─►loop exit\n```\nLoop header no longer dominates entire loop, loop guard dominates it instead.\nIf Values defined in the loop were used outside loop, all these uses should be\nreplaced by a new Phi node at loop exit which merges control flow from loop\nheader and loop guard. Based on Loop Closed SSA Form, these Phis have already\nbeen created. All we need to do is simply reset their operands to accurately\nreflect the fact that loop exit is a merge point now.\n\nOne of the main purposes of Loop Rotation is to assist other optimizations\nsuch as LICM. They may require that the rotated loop has a proper while safe\nblock to place new Values, an optional **loop land** block is hereby created to\ngive these optimizations a chance to keep them from being homeless.\n```\n         entry\n           │\n           │\n           ▼\n    ┌──loop guard\n    │      │\n    │      │\n    │      ▼\n    |  loop land <= safe land to place Values\n    │      │\n    │      │\n    │      ▼\n    │  loop header◄──┐\n    │      │         │\n    │      │         │\n    │      ▼         │\n    │  loop body     │\n    │      │         │\n    │      │         │\n    │      ▼         │\n    │  loop latch────┘\n    │      │\n    │      │\n    │      ▼\n    └─► loop exit\n```\n\nThe detailed loop rotation algorithm is summarized as following steps\n\n1. Transform the loop to Loop Closed SSA Form\n  1.1 All uses of loop defined Values will be replaced by uses of proxy phis\n2. Check whether loop can apply loop rotate\n  2.1 Loop must be a natural loop and have a single exit and so on..\n3. Rotate loop conditional test and rewire loop edges\n  3.1. Rewire loop header to loop body unconditionally.\n  3.2 Rewire loop latch to header and exit based on new conditional test.\n  3.3 Create new loop guard block and rewire loop entry to loop guard.\n  3.4 Clone conditional test from loop header to loop guard.\n  3.5 Rewire loop guard to original loop header and loop exit\n4. Reconcile broken data dependency after CFG transformation\n  4.1 Move conditional test from loop header to loop latch\n  4.2 Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\n  4.3 Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\n  4.4 Update proxy phi to use the loop phi's incoming argument which comes from loop latch since loop latch may terminate the loop now\n\n\nSome gory details in data dependencies after CFG transformation that deviate from\nintuition need to be taken into account. This has led to a more complex loop\nrotation implementation, making it less intuitive.\n\n### 4.2 Fix Data Dependencies\nThe most challenging part of Loop Rotation is the update of data dependencies\n(refer to steps 3 and 4 of the algorithm).\n\n#### Update conditional test operands\nIn original while/for loop, a critical edge is inserted at the\nend of each iteration, Phi values are updated. All subsequent\nuses of Phi rely on updated values. However, when converted\nto a do-while loop, Phi nodes may be used at the end of each\niteration before they are updated. Therefore, we need to\nreplace all subsequent uses of Phi with use of Phi parameter.\nThis way, it is equivalent to using updated values of Phi\nvalues. Here is a simple example:\n\nNormal case, if v2 uses v1 phi, and the backedge operand v4\nof v1 phi is located in the loop latch block, we only need to\nmodify the usage of v1 by v2 to the usage of v4. This prevents\nloss of updates, and the dominance relationship will not be\nbroken even after v2 is moved to the loop latch.\n\n```\nBefore:\n loop header:\n v1 = phi(0, v4)\n v2 = v1 + 1\n If v2 < 3 -> loop body, loop exit\n\n loop latch:\n v4 = const 512\n\nAfter:\n loop header:\n v1 = phi(0, v4)\n\n loop latch:\n v4 = const 512\n v2 = v4 + 1\n If v2 < 3 -> loop header, loop exit\n```\nAfter updating uses of val, we may create yet another cyclic\ndependency, i.e.\n```\n loop header:\n v1 = phi(0, v4)\n v2 = v1 + 1\n If v2 < 3 -> loop body, loop exit\n\n loop latch:\n v4 = v2 + 1\n\nAfter updating iarg of val to newUse, it becomes\n\n loop header:\n v1 = phi(0, v4)\n\n loop latch:\n v2 = v4 + 1   ;;; cyclic dependency\n v4 = v2 + 1\n If v2 < 3 -> loop header, loop exit\n```\nThis is similiar to below case, and it would be properly handled\nby updateMovedUses. For now, we just skip it to avoid infinite\nrecursion.\n\nIf there is a value v1 in the loop header that is used to define\na v2 phi in the same basic block, and this v2 phi is used in\nturn to use the value v1, there is a cyclic dependencies, i.e.\n\n```\nloop header:\nv1 = phi(0, v2)\nv2 = v1 + 1\nIf v2 < 3 -> loop body, loop exit\n```\n\nIn this case, we need to first convert the v1 phi into its\nnormal form, where its back edge parameter uses the value defined\nin the loop latch.\n\n```\nloop header:\nv1 = phi(0, v3)\nv2 = v1 + 1\nIf v2 < 3 -> loop body, loop exit\n\nloop latch:\nv3 = Copy v2\n```\n\nAfter this, the strange v1 phi is treated in the same way as\nother phis. After moving the conditional test to the loop latch,\nthe relevant parameters will also be updated, i.e., v2 will\nuse v3 instead of v1 phi:\n\n```\nloop header:\nv1 = phi(0, v3)\n\nloop latch:\nv3 = Copy v2\nv2 = v3 + 1\nIf v2 < 3 -> loop header, loop exit\n```\n\nFinally, since v3 is use of v2, after moving v2 to the loop\nlatch, updateMovedUses will update these uses and insert a\nnew v4 Phi.\n\n```\nloop header:\nv1 = phi(0, v3)\nv4 = phi(v2', v2)    ;;; v2' lives in loop guard\n\nloop latch:\nv3 = Copy v4\nv2 = v3 + 1\nIf v2 < 3 -> loop header, loop exit\n```\n#### Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\nIf the loop conditional test is \"trivial\", we will move the chain of this\nconditional test values to the loop latch, after that, they may not dominate\nthe in-loop uses anymore:\n```\n  loop header\n  v1 = phi(0, ...)\n  v2 = v1 + 1\n  If v2 < 3 ...\n\n  loop body:\n  v4 = v2 - 1\n```\n\nSo we need to create a new phi v5 at the loop header to merge the control flow\nfrom the loop guard to the loop header and the loop latch to the loop header\nand use this phi to replace the in-loop use v4. e.g.\n```\n  loop header:\n  v1 = phi(0, ...)\n  v5 = phi(v2', v2)     ;;; v2' lives in loop guard\n\n  loop body:\n  v4 = v5 - 1\n\n  loop latch:\n  v2 = v1 + 1\n  If v2 < 3 ...\n```\n\n#### Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\nLoop header no longer dominates loop exit, a new edge from loop guard to loop\nexit is created, this is not reflected in proxy phis in loop exits, i.e. these\nproxy phis miss one argument that comes from loop guard, we need to reconcile\nthe divergence\n\n```\n                              loop guard\n                                    |\nloop exit               loop exit  /\n    |          =>            |    /\nv1=phi(v1)              v1=phi(v1 v1') <= add missing g2e argument v1'\n```\n\nSince LCSSA ensures that all loop uses are closed, i.e. any out-of-loop uses\nare replaced by proxy phis in loop exit, we only need to add missing argument\nv1' to v1 proxy phi\n\n#### Update proxy phi to use the loop phi's incoming argument which comes from loop latch since loop latch may terminate the loop now\nLoop latch now terminates the loop. If proxy phi uses the loop phi that lives\nin loop header, it should be replaced by using the loop phi's incoming argument\nwhich comes from loop latch instead, this avoids losing one update.\n```\nBefore:\n  loop header:\n  v1 = phi(0, v4)\n\n  loop latch:\n  v4 = v1 + 1\n\n  loop exit\n  v3 = phi(v1, ...)\n\nAfter:\n  loop header:\n  v1 = phi(0, v4)\n\n  loop latch:\n  v4 = v1 + 1\n\n  loop exit\n  v3 = phi(v4, ...)  ;; use v4 instead of v1\n```\n\n## 5. Bug Fix\nThe loop exit created by BlockJumpTable will not be discovered by `findExits()`.\n\n![image](../images/bug_jmptable_exit.svg)\n\nThe current loop exits are only b23 and b43, but the expected ones should include b10 and b13.\n\n## 6. Performance Regression\n### 6.1 block layout\nIn original block layout algorithm, regardless of whether successors of the current basic block have `likely` attribute, the layout algorithm would place each successor right after the current basic block one by one. The improved algorithm employs a greedy approach, aiming to allocate the basic blocks of a \"trace\" together as much as possible, in order to minimize excessive jumps. i.e. For given IR:\n```\nb1:\nBlockIf -> b2 b3 (likely)\n\nb2:\nBlockPlain->b4\n\nb4:\n...\n```\nThe final block orders are as follows:\n```\nbaseline:\nb1 b2 b3 b4\n\nopt:\nb1 b2 b4 b3\n```\n\n\n### 6.2 register allocation\nAfter loop rotation, there are some significant performance regression. Taking the strconv.Atoi benchmark as an example, the performance deteriorates by about 30%. In the following example:\n\n```\n;; baseline\nb12\n00025  JMP 30\n00026  LEAQ (BX)(BX*4), R8\n00027  MOVBLZX DI, DI\n00028  INCQ AX\n00029  LEAQ (DI)(R8*2), BX\n00030  CMPQ AX, SI\nb18\n00031  JGE 38\n00032  MOVBLZX (DX)(AX*1), DI\n00033  ADDL $-48, DI\n00034  CMPB DI, $9\nb19\n00035  JLS 26\n\n;; opt\nb27\n00027  JMP 29\n00028  MOVQ R8, AX\n00029  MOVBLZX (DX)(AX*1), DI\n00030  ADDL $-48, DI\n00031  CMPB DI, $9\nb19\n00032  JHI 40\n00033  LEAQ 1(AX), R8\n00034  LEAQ (BX)(BX*4), BX\n00035  MOVBLZX DI, DI\n00036  LEAQ (DI)(BX*2), BX\n00037  CMPQ SI, R8\nb20\n00038  JGT 28\nb20\n00039  JMP 43\n```\n\nIn the code generated by the baseline, the loop includes 10 instructions `[26-35]`, whereas the optimized code contains 11 instructions `[28-38]`. This is because the baseline's loop increment instruction `i++` produced `incq ax`, while the optimized code generated is:\n\n```\n00028  MOVQ R8, AX\n...\n00033  LEAQ 1(AX), R8\n```\n\nThe culprit is empty basic block created during the split critical edge after rotation, which affects the logic of register allocation;\n\n![image](../images/bad-regalloc-regression.png)\n\nDuring the register allocation process, for the instruction `v82 = ADDQconst <int> [1] v59`, the register allocator checks if v59 is in the next basic block and examines the expected register for v59. For example, if v59 is in the next basic block and its expected register is R8, then the register allocator would also allocate the R8 register for `v82 = ADDQconst <int> [1] v59`, because the input and result are in the same register, allowing the production of `incq`. However, after loop rotation, the next basic block for v82 is the newly inserted empty basic block from the split critical edge, preventing the register allocator from knowing the expected register for v59, so v82 and v59 end up being allocated to different registers, R8 and RAX, resulting in an extra `mov` instruction. The proposed fix is to skip empty basic block and directly check the next non-empty basic block for the expected register.\n","source":"_posts/golang-licm.md","raw":"---\nlayout: post\ntitle:  \"Loop Invariant Code Motion in Golang\"\ndate:   2023-08-27\ncategories: [Compiler, Golang]\n---\n\nRecently, I proposed [Loop Invariant Code Motion(LICM)](https://github.com/golang/go/pull/64815) in Golang, this patch isn't in the main branch. I mainly wanted to share some details and the design thinking.\n\n----\n\n## 1. Loop Invariant Code Motion\nThe main idea behind LICM is to move loop invariant values outside of the loop\nso that they are only executed once, instead of being repeatedly executed with\neach iteration of the loop. In the context of LICM, if a loop invariant can be\nspeculatively executed, then it can be freely hoisted to the loop entry.\nHowever, if it cannot be speculatively executed, there is still a chance that\nit can be hoisted outside the loop under a few prerequisites:\n\n- `#1 Instruction is guaranteed to execute unconditionally`\n- `#2 Instruction does not access memory locations that may alias with other memory operations inside the loop`\n\nFor `#1`, this is guaranteed by loop rotation, where the loop is guaranteed to\nexecute at least once after rotation. But that's not the whole story. If the\ninstruction is guarded by a conditional expression (e.g., loading from a memory\naddress usually guarded by an IsInBound check), in this case, we try to hoist\nit only if the loop invariant dominates all loop exits, which implies that it\nwill be executed unconditionally as soon as it enters the loop.\nFor `#2`, we rely on a simple but efficient type-based alias analysis to know\nwhether two memory access instructions may access the same memory location.\n\n## 2. Type-based Alias Analysis\n**Type-based Alias Analysis(TBAA)** is described in Amer Diwan, Kathryn S. McKinley, J. Eliot B. Moss: Type-Based Alias Analysis. PLDI 1998\nTBAA relies on the fact that Golang is a type-safe language, i.e. different\npointer types cannot be converted to each other in Golang. Under assumption,\nTBAA attempts to identify whether two pointers may point to same memory based\non their type and value semantics. They can be summarized as follows rules:\n```\n  #0 unsafe pointer may aliases with anything even if their types are different\n  #1 a must aliases with b if a==b\n  #2 a.f aliases with b.g if f==g and a aliases with b\n  #3 a.f aliases with *b if they have same types\n  #4 a[i] aliases with *b if they have same types\n  #5 a.f never aliases with b[i]\n  #6 a[i] aliases with b[j] if a==b\n  #7 a aliases with b if they have same types\n```\n\n## 3. Loop Close SSA Form\n**Loop closed SSA form(LCSSA)** is a special form of SSA form, which is used to simplify\nloop optimization. It ensures that all values defined inside the loop are only\nused within loop. The transformation looks up loop uses outside the loop and\ninserts the appropriate \"proxy phi\" at the loop exit, after which the outside\nof the loop does not use the loop def directly but the proxy phi.\n```\n   loop header:                         loop header:\n   v3 = Phi(0, v4)                      v3 = Phi(0, v4)\n   If cond->loop latch,loop exit        If cond->loop latch,loop exit\n\n   loop latch:                          loop latch:\n   v4 = Add(v3, 1)                =>    v4 = Add(v3, 1)\n   Plain->loop header                   Plain->loop header\n\n   loop exit:                           loop exit:\n   v5 = Add(5, v3)                      v6 = Phi(v3)  <= Proxy Phi\n   Ret v18                              v5 = Add(5, v6)\n                                        Ret v18\n```\nPreviously, v5 used v3 directly, where v5 is in the loop exit which is outside\nthe loop. After LCSSA transformation, v5 uses v6, which in turn uses v3. Here,\nv6 is the proxy phi. In the context of LCSSA, we can consider the use block of\nv6 to be the loop header rather than the loop exit. This way, all values defined\nin the loop are loop \"closed\", i.e. only used within the loop.\n\nAny further changes to the loop definition only need to update the proxy phi,\nrather than iterating through all its uses and handling properties such as\nThis significantly simplifies implementation of **Loop Rotation**\n\n## 4. Loop Rotation\n### 4.1 CFG transformation\n**Loop rotation**, also known as **loop inversion**, it transforms while/for loop to\ndo-while style loop, e.g.\n\n```golang\n// Before\nfor i := 0; i < cnt; i++ {\n  ...\n}\n\n// After\nif 0 < cnt {\n  i := 0\n  do {\n    ...\n  } while(i < cnt)\n}\n```\nThe original natural loop is in form of below IR\n```\n       entry\n         │\n         │  ┌───loop latch\n         ▼  ▼       ▲\n    loop header     │\n         │  │       │\n         │  └──►loop body\n         ▼\n     loop exit\n```\nIn the terminology, loop entry dominates the entire loop, loop header contains\nthe loop conditional test, loop body refers to the code that is repeated, loop\nlatch contains the backedge to loop header, for simple loops, the loop body is\nequal to loop latch, and loop exit refers to the block that dominated by the\nentire loop.\n\nWe move the conditional test from loop header to loop latch, incoming backedge\nargument of conditional test should be updated as well otherwise we would lose\none update. Also note that any other uses of moved values should be updated\nbecause moved Values now live in loop latch and may no longer dominates their\nuses. At this point, loop latch determines whether loop continues or exits\nbased on rotated test.\n\n```\n      entry\n        │\n        │\n        ▼\n    loop header◄──┐\n        │         │\n        │         │\n        ▼         │\n    loop body     │\n        │         │\n        │         │\n        ▼         │\n    loop latch────┘\n        │\n        │\n        ▼\n    loop exit\n```\nNow loop header and loop body are executed unconditionally, this may changes\nprogram semantics while original program executes them only if test is okay.\nA so-called loop guard is inserted to ensure loop is executed at least once.\n\n```\n        entry\n          │\n          │\n          ▼\n   ┌──loop guard\n   │      │\n   │      │\n   │      ▼\n   │  loop header◄──┐\n   │      │         │\n   │      │         │\n   │      ▼         │\n   │  loop body     │\n   │      │         │\n   │      │         │\n   │      ▼         │\n   │  loop latch────┘\n   │      │\n   │      │\n   │      ▼\n   └─►loop exit\n```\nLoop header no longer dominates entire loop, loop guard dominates it instead.\nIf Values defined in the loop were used outside loop, all these uses should be\nreplaced by a new Phi node at loop exit which merges control flow from loop\nheader and loop guard. Based on Loop Closed SSA Form, these Phis have already\nbeen created. All we need to do is simply reset their operands to accurately\nreflect the fact that loop exit is a merge point now.\n\nOne of the main purposes of Loop Rotation is to assist other optimizations\nsuch as LICM. They may require that the rotated loop has a proper while safe\nblock to place new Values, an optional **loop land** block is hereby created to\ngive these optimizations a chance to keep them from being homeless.\n```\n         entry\n           │\n           │\n           ▼\n    ┌──loop guard\n    │      │\n    │      │\n    │      ▼\n    |  loop land <= safe land to place Values\n    │      │\n    │      │\n    │      ▼\n    │  loop header◄──┐\n    │      │         │\n    │      │         │\n    │      ▼         │\n    │  loop body     │\n    │      │         │\n    │      │         │\n    │      ▼         │\n    │  loop latch────┘\n    │      │\n    │      │\n    │      ▼\n    └─► loop exit\n```\n\nThe detailed loop rotation algorithm is summarized as following steps\n\n1. Transform the loop to Loop Closed SSA Form\n  1.1 All uses of loop defined Values will be replaced by uses of proxy phis\n2. Check whether loop can apply loop rotate\n  2.1 Loop must be a natural loop and have a single exit and so on..\n3. Rotate loop conditional test and rewire loop edges\n  3.1. Rewire loop header to loop body unconditionally.\n  3.2 Rewire loop latch to header and exit based on new conditional test.\n  3.3 Create new loop guard block and rewire loop entry to loop guard.\n  3.4 Clone conditional test from loop header to loop guard.\n  3.5 Rewire loop guard to original loop header and loop exit\n4. Reconcile broken data dependency after CFG transformation\n  4.1 Move conditional test from loop header to loop latch\n  4.2 Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\n  4.3 Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\n  4.4 Update proxy phi to use the loop phi's incoming argument which comes from loop latch since loop latch may terminate the loop now\n\n\nSome gory details in data dependencies after CFG transformation that deviate from\nintuition need to be taken into account. This has led to a more complex loop\nrotation implementation, making it less intuitive.\n\n### 4.2 Fix Data Dependencies\nThe most challenging part of Loop Rotation is the update of data dependencies\n(refer to steps 3 and 4 of the algorithm).\n\n#### Update conditional test operands\nIn original while/for loop, a critical edge is inserted at the\nend of each iteration, Phi values are updated. All subsequent\nuses of Phi rely on updated values. However, when converted\nto a do-while loop, Phi nodes may be used at the end of each\niteration before they are updated. Therefore, we need to\nreplace all subsequent uses of Phi with use of Phi parameter.\nThis way, it is equivalent to using updated values of Phi\nvalues. Here is a simple example:\n\nNormal case, if v2 uses v1 phi, and the backedge operand v4\nof v1 phi is located in the loop latch block, we only need to\nmodify the usage of v1 by v2 to the usage of v4. This prevents\nloss of updates, and the dominance relationship will not be\nbroken even after v2 is moved to the loop latch.\n\n```\nBefore:\n loop header:\n v1 = phi(0, v4)\n v2 = v1 + 1\n If v2 < 3 -> loop body, loop exit\n\n loop latch:\n v4 = const 512\n\nAfter:\n loop header:\n v1 = phi(0, v4)\n\n loop latch:\n v4 = const 512\n v2 = v4 + 1\n If v2 < 3 -> loop header, loop exit\n```\nAfter updating uses of val, we may create yet another cyclic\ndependency, i.e.\n```\n loop header:\n v1 = phi(0, v4)\n v2 = v1 + 1\n If v2 < 3 -> loop body, loop exit\n\n loop latch:\n v4 = v2 + 1\n\nAfter updating iarg of val to newUse, it becomes\n\n loop header:\n v1 = phi(0, v4)\n\n loop latch:\n v2 = v4 + 1   ;;; cyclic dependency\n v4 = v2 + 1\n If v2 < 3 -> loop header, loop exit\n```\nThis is similiar to below case, and it would be properly handled\nby updateMovedUses. For now, we just skip it to avoid infinite\nrecursion.\n\nIf there is a value v1 in the loop header that is used to define\na v2 phi in the same basic block, and this v2 phi is used in\nturn to use the value v1, there is a cyclic dependencies, i.e.\n\n```\nloop header:\nv1 = phi(0, v2)\nv2 = v1 + 1\nIf v2 < 3 -> loop body, loop exit\n```\n\nIn this case, we need to first convert the v1 phi into its\nnormal form, where its back edge parameter uses the value defined\nin the loop latch.\n\n```\nloop header:\nv1 = phi(0, v3)\nv2 = v1 + 1\nIf v2 < 3 -> loop body, loop exit\n\nloop latch:\nv3 = Copy v2\n```\n\nAfter this, the strange v1 phi is treated in the same way as\nother phis. After moving the conditional test to the loop latch,\nthe relevant parameters will also be updated, i.e., v2 will\nuse v3 instead of v1 phi:\n\n```\nloop header:\nv1 = phi(0, v3)\n\nloop latch:\nv3 = Copy v2\nv2 = v3 + 1\nIf v2 < 3 -> loop header, loop exit\n```\n\nFinally, since v3 is use of v2, after moving v2 to the loop\nlatch, updateMovedUses will update these uses and insert a\nnew v4 Phi.\n\n```\nloop header:\nv1 = phi(0, v3)\nv4 = phi(v2', v2)    ;;; v2' lives in loop guard\n\nloop latch:\nv3 = Copy v4\nv2 = v3 + 1\nIf v2 < 3 -> loop header, loop exit\n```\n#### Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\nIf the loop conditional test is \"trivial\", we will move the chain of this\nconditional test values to the loop latch, after that, they may not dominate\nthe in-loop uses anymore:\n```\n  loop header\n  v1 = phi(0, ...)\n  v2 = v1 + 1\n  If v2 < 3 ...\n\n  loop body:\n  v4 = v2 - 1\n```\n\nSo we need to create a new phi v5 at the loop header to merge the control flow\nfrom the loop guard to the loop header and the loop latch to the loop header\nand use this phi to replace the in-loop use v4. e.g.\n```\n  loop header:\n  v1 = phi(0, ...)\n  v5 = phi(v2', v2)     ;;; v2' lives in loop guard\n\n  loop body:\n  v4 = v5 - 1\n\n  loop latch:\n  v2 = v1 + 1\n  If v2 < 3 ...\n```\n\n#### Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\nLoop header no longer dominates loop exit, a new edge from loop guard to loop\nexit is created, this is not reflected in proxy phis in loop exits, i.e. these\nproxy phis miss one argument that comes from loop guard, we need to reconcile\nthe divergence\n\n```\n                              loop guard\n                                    |\nloop exit               loop exit  /\n    |          =>            |    /\nv1=phi(v1)              v1=phi(v1 v1') <= add missing g2e argument v1'\n```\n\nSince LCSSA ensures that all loop uses are closed, i.e. any out-of-loop uses\nare replaced by proxy phis in loop exit, we only need to add missing argument\nv1' to v1 proxy phi\n\n#### Update proxy phi to use the loop phi's incoming argument which comes from loop latch since loop latch may terminate the loop now\nLoop latch now terminates the loop. If proxy phi uses the loop phi that lives\nin loop header, it should be replaced by using the loop phi's incoming argument\nwhich comes from loop latch instead, this avoids losing one update.\n```\nBefore:\n  loop header:\n  v1 = phi(0, v4)\n\n  loop latch:\n  v4 = v1 + 1\n\n  loop exit\n  v3 = phi(v1, ...)\n\nAfter:\n  loop header:\n  v1 = phi(0, v4)\n\n  loop latch:\n  v4 = v1 + 1\n\n  loop exit\n  v3 = phi(v4, ...)  ;; use v4 instead of v1\n```\n\n## 5. Bug Fix\nThe loop exit created by BlockJumpTable will not be discovered by `findExits()`.\n\n![image](../images/bug_jmptable_exit.svg)\n\nThe current loop exits are only b23 and b43, but the expected ones should include b10 and b13.\n\n## 6. Performance Regression\n### 6.1 block layout\nIn original block layout algorithm, regardless of whether successors of the current basic block have `likely` attribute, the layout algorithm would place each successor right after the current basic block one by one. The improved algorithm employs a greedy approach, aiming to allocate the basic blocks of a \"trace\" together as much as possible, in order to minimize excessive jumps. i.e. For given IR:\n```\nb1:\nBlockIf -> b2 b3 (likely)\n\nb2:\nBlockPlain->b4\n\nb4:\n...\n```\nThe final block orders are as follows:\n```\nbaseline:\nb1 b2 b3 b4\n\nopt:\nb1 b2 b4 b3\n```\n\n\n### 6.2 register allocation\nAfter loop rotation, there are some significant performance regression. Taking the strconv.Atoi benchmark as an example, the performance deteriorates by about 30%. In the following example:\n\n```\n;; baseline\nb12\n00025  JMP 30\n00026  LEAQ (BX)(BX*4), R8\n00027  MOVBLZX DI, DI\n00028  INCQ AX\n00029  LEAQ (DI)(R8*2), BX\n00030  CMPQ AX, SI\nb18\n00031  JGE 38\n00032  MOVBLZX (DX)(AX*1), DI\n00033  ADDL $-48, DI\n00034  CMPB DI, $9\nb19\n00035  JLS 26\n\n;; opt\nb27\n00027  JMP 29\n00028  MOVQ R8, AX\n00029  MOVBLZX (DX)(AX*1), DI\n00030  ADDL $-48, DI\n00031  CMPB DI, $9\nb19\n00032  JHI 40\n00033  LEAQ 1(AX), R8\n00034  LEAQ (BX)(BX*4), BX\n00035  MOVBLZX DI, DI\n00036  LEAQ (DI)(BX*2), BX\n00037  CMPQ SI, R8\nb20\n00038  JGT 28\nb20\n00039  JMP 43\n```\n\nIn the code generated by the baseline, the loop includes 10 instructions `[26-35]`, whereas the optimized code contains 11 instructions `[28-38]`. This is because the baseline's loop increment instruction `i++` produced `incq ax`, while the optimized code generated is:\n\n```\n00028  MOVQ R8, AX\n...\n00033  LEAQ 1(AX), R8\n```\n\nThe culprit is empty basic block created during the split critical edge after rotation, which affects the logic of register allocation;\n\n![image](../images/bad-regalloc-regression.png)\n\nDuring the register allocation process, for the instruction `v82 = ADDQconst <int> [1] v59`, the register allocator checks if v59 is in the next basic block and examines the expected register for v59. For example, if v59 is in the next basic block and its expected register is R8, then the register allocator would also allocate the R8 register for `v82 = ADDQconst <int> [1] v59`, because the input and result are in the same register, allowing the production of `incq`. However, after loop rotation, the next basic block for v82 is the newly inserted empty basic block from the split critical edge, preventing the register allocator from knowing the expected register for v59, so v82 and v59 end up being allocated to different registers, R8 and RAX, resulting in an extra `mov` instruction. The proposed fix is to skip empty basic block and directly check the next non-empty basic block for the expected register.\n","slug":"golang-licm","published":1,"updated":"2026-01-21T03:18:57.374Z","_id":"cmkng84wz000334px4ibp9jfc","comments":1,"photos":[],"content":"<p>Recently, I proposed <a href=\"https://github.com/golang/go/pull/64815\">Loop Invariant Code Motion(LICM)</a> in Golang, this patch isn’t in the main branch. I mainly wanted to share some details and the design thinking.</p>\n<hr>\n<h2 id=\"1-Loop-Invariant-Code-Motion\"><a href=\"#1-Loop-Invariant-Code-Motion\" class=\"headerlink\" title=\"1. Loop Invariant Code Motion\"></a>1. Loop Invariant Code Motion</h2><p>The main idea behind LICM is to move loop invariant values outside of the loop<br>so that they are only executed once, instead of being repeatedly executed with<br>each iteration of the loop. In the context of LICM, if a loop invariant can be<br>speculatively executed, then it can be freely hoisted to the loop entry.<br>However, if it cannot be speculatively executed, there is still a chance that<br>it can be hoisted outside the loop under a few prerequisites:</p>\n<ul>\n<li><code>#1 Instruction is guaranteed to execute unconditionally</code></li>\n<li><code>#2 Instruction does not access memory locations that may alias with other memory operations inside the loop</code></li>\n</ul>\n<p>For <code>#1</code>, this is guaranteed by loop rotation, where the loop is guaranteed to<br>execute at least once after rotation. But that’s not the whole story. If the<br>instruction is guarded by a conditional expression (e.g., loading from a memory<br>address usually guarded by an IsInBound check), in this case, we try to hoist<br>it only if the loop invariant dominates all loop exits, which implies that it<br>will be executed unconditionally as soon as it enters the loop.<br>For <code>#2</code>, we rely on a simple but efficient type-based alias analysis to know<br>whether two memory access instructions may access the same memory location.</p>\n<h2 id=\"2-Type-based-Alias-Analysis\"><a href=\"#2-Type-based-Alias-Analysis\" class=\"headerlink\" title=\"2. Type-based Alias Analysis\"></a>2. Type-based Alias Analysis</h2><p><strong>Type-based Alias Analysis(TBAA)</strong> is described in Amer Diwan, Kathryn S. McKinley, J. Eliot B. Moss: Type-Based Alias Analysis. PLDI 1998<br>TBAA relies on the fact that Golang is a type-safe language, i.e. different<br>pointer types cannot be converted to each other in Golang. Under assumption,<br>TBAA attempts to identify whether two pointers may point to same memory based<br>on their type and value semantics. They can be summarized as follows rules:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#0 unsafe pointer may aliases with anything even if their types are different</span><br><span class=\"line\">#1 a must aliases with b if a==b</span><br><span class=\"line\">#2 a.f aliases with b.g if f==g and a aliases with b</span><br><span class=\"line\">#3 a.f aliases with *b if they have same types</span><br><span class=\"line\">#4 a[i] aliases with *b if they have same types</span><br><span class=\"line\">#5 a.f never aliases with b[i]</span><br><span class=\"line\">#6 a[i] aliases with b[j] if a==b</span><br><span class=\"line\">#7 a aliases with b if they have same types</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Loop-Close-SSA-Form\"><a href=\"#3-Loop-Close-SSA-Form\" class=\"headerlink\" title=\"3. Loop Close SSA Form\"></a>3. Loop Close SSA Form</h2><p><strong>Loop closed SSA form(LCSSA)</strong> is a special form of SSA form, which is used to simplify<br>loop optimization. It ensures that all values defined inside the loop are only<br>used within loop. The transformation looks up loop uses outside the loop and<br>inserts the appropriate “proxy phi” at the loop exit, after which the outside<br>of the loop does not use the loop def directly but the proxy phi.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:                         loop header:</span><br><span class=\"line\">v3 = Phi(0, v4)                      v3 = Phi(0, v4)</span><br><span class=\"line\">If cond-&gt;loop latch,loop exit        If cond-&gt;loop latch,loop exit</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:                          loop latch:</span><br><span class=\"line\">v4 = Add(v3, 1)                =&gt;    v4 = Add(v3, 1)</span><br><span class=\"line\">Plain-&gt;loop header                   Plain-&gt;loop header</span><br><span class=\"line\"></span><br><span class=\"line\">loop exit:                           loop exit:</span><br><span class=\"line\">v5 = Add(5, v3)                      v6 = Phi(v3)  &lt;= Proxy Phi</span><br><span class=\"line\">Ret v18                              v5 = Add(5, v6)</span><br><span class=\"line\">                                     Ret v18</span><br></pre></td></tr></table></figure>\n<p>Previously, v5 used v3 directly, where v5 is in the loop exit which is outside<br>the loop. After LCSSA transformation, v5 uses v6, which in turn uses v3. Here,<br>v6 is the proxy phi. In the context of LCSSA, we can consider the use block of<br>v6 to be the loop header rather than the loop exit. This way, all values defined<br>in the loop are loop “closed”, i.e. only used within the loop.</p>\n<p>Any further changes to the loop definition only need to update the proxy phi,<br>rather than iterating through all its uses and handling properties such as<br>This significantly simplifies implementation of <strong>Loop Rotation</strong></p>\n<h2 id=\"4-Loop-Rotation\"><a href=\"#4-Loop-Rotation\" class=\"headerlink\" title=\"4. Loop Rotation\"></a>4. Loop Rotation</h2><h3 id=\"4-1-CFG-transformation\"><a href=\"#4-1-CFG-transformation\" class=\"headerlink\" title=\"4.1 CFG transformation\"></a>4.1 CFG transformation</h3><p><strong>Loop rotation</strong>, also known as <strong>loop inversion</strong>, it transforms while&#x2F;for loop to<br>do-while style loop, e.g.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; cnt; i++ &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt; cnt &#123;</span><br><span class=\"line\">  i := <span class=\"number\">0</span></span><br><span class=\"line\">  do &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125; while(i &lt; cnt)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The original natural loop is in form of below IR</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   entry</span><br><span class=\"line\">     │</span><br><span class=\"line\">     │  ┌───loop latch</span><br><span class=\"line\">     ▼  ▼       ▲</span><br><span class=\"line\">loop header     │</span><br><span class=\"line\">     │  │       │</span><br><span class=\"line\">     │  └──►loop body</span><br><span class=\"line\">     ▼</span><br><span class=\"line\"> loop exit</span><br></pre></td></tr></table></figure>\n<p>In the terminology, loop entry dominates the entire loop, loop header contains<br>the loop conditional test, loop body refers to the code that is repeated, loop<br>latch contains the backedge to loop header, for simple loops, the loop body is<br>equal to loop latch, and loop exit refers to the block that dominated by the<br>entire loop.</p>\n<p>We move the conditional test from loop header to loop latch, incoming backedge<br>argument of conditional test should be updated as well otherwise we would lose<br>one update. Also note that any other uses of moved values should be updated<br>because moved Values now live in loop latch and may no longer dominates their<br>uses. At this point, loop latch determines whether loop continues or exits<br>based on rotated test.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  entry</span><br><span class=\"line\">    │</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ▼</span><br><span class=\"line\">loop header◄──┐</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    ▼         │</span><br><span class=\"line\">loop body     │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    ▼         │</span><br><span class=\"line\">loop latch────┘</span><br><span class=\"line\">    │</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ▼</span><br><span class=\"line\">loop exit</span><br></pre></td></tr></table></figure>\n<p>Now loop header and loop body are executed unconditionally, this may changes<br>program semantics while original program executes them only if test is okay.<br>A so-called loop guard is inserted to ensure loop is executed at least once.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     entry</span><br><span class=\"line\">       │</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">┌──loop guard</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">│  loop header◄──┐</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop body     │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop latch────┘</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">└─►loop exit</span><br></pre></td></tr></table></figure>\n<p>Loop header no longer dominates entire loop, loop guard dominates it instead.<br>If Values defined in the loop were used outside loop, all these uses should be<br>replaced by a new Phi node at loop exit which merges control flow from loop<br>header and loop guard. Based on Loop Closed SSA Form, these Phis have already<br>been created. All we need to do is simply reset their operands to accurately<br>reflect the fact that loop exit is a merge point now.</p>\n<p>One of the main purposes of Loop Rotation is to assist other optimizations<br>such as LICM. They may require that the rotated loop has a proper while safe<br>block to place new Values, an optional <strong>loop land</strong> block is hereby created to<br>give these optimizations a chance to keep them from being homeless.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     entry</span><br><span class=\"line\">       │</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">┌──loop guard</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">|  loop land &lt;= safe land to place Values</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">│  loop header◄──┐</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop body     │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop latch────┘</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">└─► loop exit</span><br></pre></td></tr></table></figure>\n\n<p>The detailed loop rotation algorithm is summarized as following steps</p>\n<ol>\n<li>Transform the loop to Loop Closed SSA Form<br>  1.1 All uses of loop defined Values will be replaced by uses of proxy phis</li>\n<li>Check whether loop can apply loop rotate<br>  2.1 Loop must be a natural loop and have a single exit and so on..</li>\n<li>Rotate loop conditional test and rewire loop edges<br>  3.1. Rewire loop header to loop body unconditionally.<br>  3.2 Rewire loop latch to header and exit based on new conditional test.<br>  3.3 Create new loop guard block and rewire loop entry to loop guard.<br>  3.4 Clone conditional test from loop header to loop guard.<br>  3.5 Rewire loop guard to original loop header and loop exit</li>\n<li>Reconcile broken data dependency after CFG transformation<br>  4.1 Move conditional test from loop header to loop latch<br>  4.2 Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch<br>  4.3 Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created<br>  4.4 Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now</li>\n</ol>\n<p>Some gory details in data dependencies after CFG transformation that deviate from<br>intuition need to be taken into account. This has led to a more complex loop<br>rotation implementation, making it less intuitive.</p>\n<h3 id=\"4-2-Fix-Data-Dependencies\"><a href=\"#4-2-Fix-Data-Dependencies\" class=\"headerlink\" title=\"4.2 Fix Data Dependencies\"></a>4.2 Fix Data Dependencies</h3><p>The most challenging part of Loop Rotation is the update of data dependencies<br>(refer to steps 3 and 4 of the algorithm).</p>\n<h4 id=\"Update-conditional-test-operands\"><a href=\"#Update-conditional-test-operands\" class=\"headerlink\" title=\"Update conditional test operands\"></a>Update conditional test operands</h4><p>In original while&#x2F;for loop, a critical edge is inserted at the<br>end of each iteration, Phi values are updated. All subsequent<br>uses of Phi rely on updated values. However, when converted<br>to a do-while loop, Phi nodes may be used at the end of each<br>iteration before they are updated. Therefore, we need to<br>replace all subsequent uses of Phi with use of Phi parameter.<br>This way, it is equivalent to using updated values of Phi<br>values. Here is a simple example:</p>\n<p>Normal case, if v2 uses v1 phi, and the backedge operand v4<br>of v1 phi is located in the loop latch block, we only need to<br>modify the usage of v1 by v2 to the usage of v4. This prevents<br>loss of updates, and the dominance relationship will not be<br>broken even after v2 is moved to the loop latch.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before:</span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"> v2 = v1 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = const 512</span><br><span class=\"line\"></span><br><span class=\"line\">After:</span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = const 512</span><br><span class=\"line\"> v2 = v4 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<p>After updating uses of val, we may create yet another cyclic<br>dependency, i.e.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"> v2 = v1 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = v2 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">After updating iarg of val to newUse, it becomes</span><br><span class=\"line\"></span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v2 = v4 + 1   ;;; cyclic dependency</span><br><span class=\"line\"> v4 = v2 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<p>This is similiar to below case, and it would be properly handled<br>by updateMovedUses. For now, we just skip it to avoid infinite<br>recursion.</p>\n<p>If there is a value v1 in the loop header that is used to define<br>a v2 phi in the same basic block, and this v2 phi is used in<br>turn to use the value v1, there is a cyclic dependencies, i.e.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v2)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop body, loop exit</span><br></pre></td></tr></table></figure>\n\n<p>In this case, we need to first convert the v1 phi into its<br>normal form, where its back edge parameter uses the value defined<br>in the loop latch.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v2</span><br></pre></td></tr></table></figure>\n\n<p>After this, the strange v1 phi is treated in the same way as<br>other phis. After moving the conditional test to the loop latch,<br>the relevant parameters will also be updated, i.e., v2 will<br>use v3 instead of v1 phi:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v2</span><br><span class=\"line\">v2 = v3 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n\n<p>Finally, since v3 is use of v2, after moving v2 to the loop<br>latch, updateMovedUses will update these uses and insert a<br>new v4 Phi.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\">v4 = phi(v2&#x27;, v2)    ;;; v2&#x27; lives in loop guard</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v4</span><br><span class=\"line\">v2 = v3 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<h4 id=\"Update-uses-of-moved-Values-because-these-defs-no-longer-dominates-uses-after-they-were-moved-to-loop-latch\"><a href=\"#Update-uses-of-moved-Values-because-these-defs-no-longer-dominates-uses-after-they-were-moved-to-loop-latch\" class=\"headerlink\" title=\"Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\"></a>Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch</h4><p>If the loop conditional test is “trivial”, we will move the chain of this<br>conditional test values to the loop latch, after that, they may not dominate<br>the in-loop uses anymore:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header</span><br><span class=\"line\">v1 = phi(0, ...)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 ...</span><br><span class=\"line\"></span><br><span class=\"line\">loop body:</span><br><span class=\"line\">v4 = v2 - 1</span><br></pre></td></tr></table></figure>\n\n<p>So we need to create a new phi v5 at the loop header to merge the control flow<br>from the loop guard to the loop header and the loop latch to the loop header<br>and use this phi to replace the in-loop use v4. e.g.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, ...)</span><br><span class=\"line\">v5 = phi(v2&#x27;, v2)     ;;; v2&#x27; lives in loop guard</span><br><span class=\"line\"></span><br><span class=\"line\">loop body:</span><br><span class=\"line\">v4 = v5 - 1</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 ...</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Add-corresponding-argument-for-phis-at-loop-exits-since-new-edge-from-loop-guard-to-loop-exit-had-been-created\"><a href=\"#Add-corresponding-argument-for-phis-at-loop-exits-since-new-edge-from-loop-guard-to-loop-exit-had-been-created\" class=\"headerlink\" title=\"Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\"></a>Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created</h4><p>Loop header no longer dominates loop exit, a new edge from loop guard to loop<br>exit is created, this is not reflected in proxy phis in loop exits, i.e. these<br>proxy phis miss one argument that comes from loop guard, we need to reconcile<br>the divergence</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                              loop guard</span><br><span class=\"line\">                                    |</span><br><span class=\"line\">loop exit               loop exit  /</span><br><span class=\"line\">    |          =&gt;            |    /</span><br><span class=\"line\">v1=phi(v1)              v1=phi(v1 v1&#x27;) &lt;= add missing g2e argument v1&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>Since LCSSA ensures that all loop uses are closed, i.e. any out-of-loop uses<br>are replaced by proxy phis in loop exit, we only need to add missing argument<br>v1’ to v1 proxy phi</p>\n<h4 id=\"Update-proxy-phi-to-use-the-loop-phi’s-incoming-argument-which-comes-from-loop-latch-since-loop-latch-may-terminate-the-loop-now\"><a href=\"#Update-proxy-phi-to-use-the-loop-phi’s-incoming-argument-which-comes-from-loop-latch-since-loop-latch-may-terminate-the-loop-now\" class=\"headerlink\" title=\"Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now\"></a>Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now</h4><p>Loop latch now terminates the loop. If proxy phi uses the loop phi that lives<br>in loop header, it should be replaced by using the loop phi’s incoming argument<br>which comes from loop latch instead, this avoids losing one update.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before:</span><br><span class=\"line\">  loop header:</span><br><span class=\"line\">  v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\">  loop latch:</span><br><span class=\"line\">  v4 = v1 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">  loop exit</span><br><span class=\"line\">  v3 = phi(v1, ...)</span><br><span class=\"line\"></span><br><span class=\"line\">After:</span><br><span class=\"line\">  loop header:</span><br><span class=\"line\">  v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\">  loop latch:</span><br><span class=\"line\">  v4 = v1 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">  loop exit</span><br><span class=\"line\">  v3 = phi(v4, ...)  ;; use v4 instead of v1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-Bug-Fix\"><a href=\"#5-Bug-Fix\" class=\"headerlink\" title=\"5. Bug Fix\"></a>5. Bug Fix</h2><p>The loop exit created by BlockJumpTable will not be discovered by <code>findExits()</code>.</p>\n<p><img src=\"/../images/bug_jmptable_exit.svg\" alt=\"image\"></p>\n<p>The current loop exits are only b23 and b43, but the expected ones should include b10 and b13.</p>\n<h2 id=\"6-Performance-Regression\"><a href=\"#6-Performance-Regression\" class=\"headerlink\" title=\"6. Performance Regression\"></a>6. Performance Regression</h2><h3 id=\"6-1-block-layout\"><a href=\"#6-1-block-layout\" class=\"headerlink\" title=\"6.1 block layout\"></a>6.1 block layout</h3><p>In original block layout algorithm, regardless of whether successors of the current basic block have <code>likely</code> attribute, the layout algorithm would place each successor right after the current basic block one by one. The improved algorithm employs a greedy approach, aiming to allocate the basic blocks of a “trace” together as much as possible, in order to minimize excessive jumps. i.e. For given IR:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1:</span><br><span class=\"line\">BlockIf -&gt; b2 b3 (likely)</span><br><span class=\"line\"></span><br><span class=\"line\">b2:</span><br><span class=\"line\">BlockPlain-&gt;b4</span><br><span class=\"line\"></span><br><span class=\"line\">b4:</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>The final block orders are as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baseline:</span><br><span class=\"line\">b1 b2 b3 b4</span><br><span class=\"line\"></span><br><span class=\"line\">opt:</span><br><span class=\"line\">b1 b2 b4 b3</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-2-register-allocation\"><a href=\"#6-2-register-allocation\" class=\"headerlink\" title=\"6.2 register allocation\"></a>6.2 register allocation</h3><p>After loop rotation, there are some significant performance regression. Taking the strconv.Atoi benchmark as an example, the performance deteriorates by about 30%. In the following example:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; baseline</span><br><span class=\"line\">b12</span><br><span class=\"line\">00025  JMP 30</span><br><span class=\"line\">00026  LEAQ (BX)(BX*4), R8</span><br><span class=\"line\">00027  MOVBLZX DI, DI</span><br><span class=\"line\">00028  INCQ AX</span><br><span class=\"line\">00029  LEAQ (DI)(R8*2), BX</span><br><span class=\"line\">00030  CMPQ AX, SI</span><br><span class=\"line\">b18</span><br><span class=\"line\">00031  JGE 38</span><br><span class=\"line\">00032  MOVBLZX (DX)(AX*1), DI</span><br><span class=\"line\">00033  ADDL $-48, DI</span><br><span class=\"line\">00034  CMPB DI, $9</span><br><span class=\"line\">b19</span><br><span class=\"line\">00035  JLS 26</span><br><span class=\"line\"></span><br><span class=\"line\">;; opt</span><br><span class=\"line\">b27</span><br><span class=\"line\">00027  JMP 29</span><br><span class=\"line\">00028  MOVQ R8, AX</span><br><span class=\"line\">00029  MOVBLZX (DX)(AX*1), DI</span><br><span class=\"line\">00030  ADDL $-48, DI</span><br><span class=\"line\">00031  CMPB DI, $9</span><br><span class=\"line\">b19</span><br><span class=\"line\">00032  JHI 40</span><br><span class=\"line\">00033  LEAQ 1(AX), R8</span><br><span class=\"line\">00034  LEAQ (BX)(BX*4), BX</span><br><span class=\"line\">00035  MOVBLZX DI, DI</span><br><span class=\"line\">00036  LEAQ (DI)(BX*2), BX</span><br><span class=\"line\">00037  CMPQ SI, R8</span><br><span class=\"line\">b20</span><br><span class=\"line\">00038  JGT 28</span><br><span class=\"line\">b20</span><br><span class=\"line\">00039  JMP 43</span><br></pre></td></tr></table></figure>\n\n<p>In the code generated by the baseline, the loop includes 10 instructions <code>[26-35]</code>, whereas the optimized code contains 11 instructions <code>[28-38]</code>. This is because the baseline’s loop increment instruction <code>i++</code> produced <code>incq ax</code>, while the optimized code generated is:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00028  MOVQ R8, AX</span><br><span class=\"line\">...</span><br><span class=\"line\">00033  LEAQ 1(AX), R8</span><br></pre></td></tr></table></figure>\n\n<p>The culprit is empty basic block created during the split critical edge after rotation, which affects the logic of register allocation;</p>\n<p><img src=\"/../images/bad-regalloc-regression.png\" alt=\"image\"></p>\n<p>During the register allocation process, for the instruction <code>v82 = ADDQconst &lt;int&gt; [1] v59</code>, the register allocator checks if v59 is in the next basic block and examines the expected register for v59. For example, if v59 is in the next basic block and its expected register is R8, then the register allocator would also allocate the R8 register for <code>v82 = ADDQconst &lt;int&gt; [1] v59</code>, because the input and result are in the same register, allowing the production of <code>incq</code>. However, after loop rotation, the next basic block for v82 is the newly inserted empty basic block from the split critical edge, preventing the register allocator from knowing the expected register for v59, so v82 and v59 end up being allocated to different registers, R8 and RAX, resulting in an extra <code>mov</code> instruction. The proposed fix is to skip empty basic block and directly check the next non-empty basic block for the expected register.</p>\n","excerpt":"","more":"<p>Recently, I proposed <a href=\"https://github.com/golang/go/pull/64815\">Loop Invariant Code Motion(LICM)</a> in Golang, this patch isn’t in the main branch. I mainly wanted to share some details and the design thinking.</p>\n<hr>\n<h2 id=\"1-Loop-Invariant-Code-Motion\"><a href=\"#1-Loop-Invariant-Code-Motion\" class=\"headerlink\" title=\"1. Loop Invariant Code Motion\"></a>1. Loop Invariant Code Motion</h2><p>The main idea behind LICM is to move loop invariant values outside of the loop<br>so that they are only executed once, instead of being repeatedly executed with<br>each iteration of the loop. In the context of LICM, if a loop invariant can be<br>speculatively executed, then it can be freely hoisted to the loop entry.<br>However, if it cannot be speculatively executed, there is still a chance that<br>it can be hoisted outside the loop under a few prerequisites:</p>\n<ul>\n<li><code>#1 Instruction is guaranteed to execute unconditionally</code></li>\n<li><code>#2 Instruction does not access memory locations that may alias with other memory operations inside the loop</code></li>\n</ul>\n<p>For <code>#1</code>, this is guaranteed by loop rotation, where the loop is guaranteed to<br>execute at least once after rotation. But that’s not the whole story. If the<br>instruction is guarded by a conditional expression (e.g., loading from a memory<br>address usually guarded by an IsInBound check), in this case, we try to hoist<br>it only if the loop invariant dominates all loop exits, which implies that it<br>will be executed unconditionally as soon as it enters the loop.<br>For <code>#2</code>, we rely on a simple but efficient type-based alias analysis to know<br>whether two memory access instructions may access the same memory location.</p>\n<h2 id=\"2-Type-based-Alias-Analysis\"><a href=\"#2-Type-based-Alias-Analysis\" class=\"headerlink\" title=\"2. Type-based Alias Analysis\"></a>2. Type-based Alias Analysis</h2><p><strong>Type-based Alias Analysis(TBAA)</strong> is described in Amer Diwan, Kathryn S. McKinley, J. Eliot B. Moss: Type-Based Alias Analysis. PLDI 1998<br>TBAA relies on the fact that Golang is a type-safe language, i.e. different<br>pointer types cannot be converted to each other in Golang. Under assumption,<br>TBAA attempts to identify whether two pointers may point to same memory based<br>on their type and value semantics. They can be summarized as follows rules:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#0 unsafe pointer may aliases with anything even if their types are different</span><br><span class=\"line\">#1 a must aliases with b if a==b</span><br><span class=\"line\">#2 a.f aliases with b.g if f==g and a aliases with b</span><br><span class=\"line\">#3 a.f aliases with *b if they have same types</span><br><span class=\"line\">#4 a[i] aliases with *b if they have same types</span><br><span class=\"line\">#5 a.f never aliases with b[i]</span><br><span class=\"line\">#6 a[i] aliases with b[j] if a==b</span><br><span class=\"line\">#7 a aliases with b if they have same types</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Loop-Close-SSA-Form\"><a href=\"#3-Loop-Close-SSA-Form\" class=\"headerlink\" title=\"3. Loop Close SSA Form\"></a>3. Loop Close SSA Form</h2><p><strong>Loop closed SSA form(LCSSA)</strong> is a special form of SSA form, which is used to simplify<br>loop optimization. It ensures that all values defined inside the loop are only<br>used within loop. The transformation looks up loop uses outside the loop and<br>inserts the appropriate “proxy phi” at the loop exit, after which the outside<br>of the loop does not use the loop def directly but the proxy phi.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:                         loop header:</span><br><span class=\"line\">v3 = Phi(0, v4)                      v3 = Phi(0, v4)</span><br><span class=\"line\">If cond-&gt;loop latch,loop exit        If cond-&gt;loop latch,loop exit</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:                          loop latch:</span><br><span class=\"line\">v4 = Add(v3, 1)                =&gt;    v4 = Add(v3, 1)</span><br><span class=\"line\">Plain-&gt;loop header                   Plain-&gt;loop header</span><br><span class=\"line\"></span><br><span class=\"line\">loop exit:                           loop exit:</span><br><span class=\"line\">v5 = Add(5, v3)                      v6 = Phi(v3)  &lt;= Proxy Phi</span><br><span class=\"line\">Ret v18                              v5 = Add(5, v6)</span><br><span class=\"line\">                                     Ret v18</span><br></pre></td></tr></table></figure>\n<p>Previously, v5 used v3 directly, where v5 is in the loop exit which is outside<br>the loop. After LCSSA transformation, v5 uses v6, which in turn uses v3. Here,<br>v6 is the proxy phi. In the context of LCSSA, we can consider the use block of<br>v6 to be the loop header rather than the loop exit. This way, all values defined<br>in the loop are loop “closed”, i.e. only used within the loop.</p>\n<p>Any further changes to the loop definition only need to update the proxy phi,<br>rather than iterating through all its uses and handling properties such as<br>This significantly simplifies implementation of <strong>Loop Rotation</strong></p>\n<h2 id=\"4-Loop-Rotation\"><a href=\"#4-Loop-Rotation\" class=\"headerlink\" title=\"4. Loop Rotation\"></a>4. Loop Rotation</h2><h3 id=\"4-1-CFG-transformation\"><a href=\"#4-1-CFG-transformation\" class=\"headerlink\" title=\"4.1 CFG transformation\"></a>4.1 CFG transformation</h3><p><strong>Loop rotation</strong>, also known as <strong>loop inversion</strong>, it transforms while&#x2F;for loop to<br>do-while style loop, e.g.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; cnt; i++ &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt; cnt &#123;</span><br><span class=\"line\">  i := <span class=\"number\">0</span></span><br><span class=\"line\">  do &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125; while(i &lt; cnt)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The original natural loop is in form of below IR</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   entry</span><br><span class=\"line\">     │</span><br><span class=\"line\">     │  ┌───loop latch</span><br><span class=\"line\">     ▼  ▼       ▲</span><br><span class=\"line\">loop header     │</span><br><span class=\"line\">     │  │       │</span><br><span class=\"line\">     │  └──►loop body</span><br><span class=\"line\">     ▼</span><br><span class=\"line\"> loop exit</span><br></pre></td></tr></table></figure>\n<p>In the terminology, loop entry dominates the entire loop, loop header contains<br>the loop conditional test, loop body refers to the code that is repeated, loop<br>latch contains the backedge to loop header, for simple loops, the loop body is<br>equal to loop latch, and loop exit refers to the block that dominated by the<br>entire loop.</p>\n<p>We move the conditional test from loop header to loop latch, incoming backedge<br>argument of conditional test should be updated as well otherwise we would lose<br>one update. Also note that any other uses of moved values should be updated<br>because moved Values now live in loop latch and may no longer dominates their<br>uses. At this point, loop latch determines whether loop continues or exits<br>based on rotated test.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  entry</span><br><span class=\"line\">    │</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ▼</span><br><span class=\"line\">loop header◄──┐</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    ▼         │</span><br><span class=\"line\">loop body     │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    │         │</span><br><span class=\"line\">    ▼         │</span><br><span class=\"line\">loop latch────┘</span><br><span class=\"line\">    │</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ▼</span><br><span class=\"line\">loop exit</span><br></pre></td></tr></table></figure>\n<p>Now loop header and loop body are executed unconditionally, this may changes<br>program semantics while original program executes them only if test is okay.<br>A so-called loop guard is inserted to ensure loop is executed at least once.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     entry</span><br><span class=\"line\">       │</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">┌──loop guard</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">│  loop header◄──┐</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop body     │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop latch────┘</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">└─►loop exit</span><br></pre></td></tr></table></figure>\n<p>Loop header no longer dominates entire loop, loop guard dominates it instead.<br>If Values defined in the loop were used outside loop, all these uses should be<br>replaced by a new Phi node at loop exit which merges control flow from loop<br>header and loop guard. Based on Loop Closed SSA Form, these Phis have already<br>been created. All we need to do is simply reset their operands to accurately<br>reflect the fact that loop exit is a merge point now.</p>\n<p>One of the main purposes of Loop Rotation is to assist other optimizations<br>such as LICM. They may require that the rotated loop has a proper while safe<br>block to place new Values, an optional <strong>loop land</strong> block is hereby created to<br>give these optimizations a chance to keep them from being homeless.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     entry</span><br><span class=\"line\">       │</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">┌──loop guard</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">|  loop land &lt;= safe land to place Values</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">│  loop header◄──┐</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop body     │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      │         │</span><br><span class=\"line\">│      ▼         │</span><br><span class=\"line\">│  loop latch────┘</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      ▼</span><br><span class=\"line\">└─► loop exit</span><br></pre></td></tr></table></figure>\n\n<p>The detailed loop rotation algorithm is summarized as following steps</p>\n<ol>\n<li>Transform the loop to Loop Closed SSA Form<br>  1.1 All uses of loop defined Values will be replaced by uses of proxy phis</li>\n<li>Check whether loop can apply loop rotate<br>  2.1 Loop must be a natural loop and have a single exit and so on..</li>\n<li>Rotate loop conditional test and rewire loop edges<br>  3.1. Rewire loop header to loop body unconditionally.<br>  3.2 Rewire loop latch to header and exit based on new conditional test.<br>  3.3 Create new loop guard block and rewire loop entry to loop guard.<br>  3.4 Clone conditional test from loop header to loop guard.<br>  3.5 Rewire loop guard to original loop header and loop exit</li>\n<li>Reconcile broken data dependency after CFG transformation<br>  4.1 Move conditional test from loop header to loop latch<br>  4.2 Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch<br>  4.3 Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created<br>  4.4 Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now</li>\n</ol>\n<p>Some gory details in data dependencies after CFG transformation that deviate from<br>intuition need to be taken into account. This has led to a more complex loop<br>rotation implementation, making it less intuitive.</p>\n<h3 id=\"4-2-Fix-Data-Dependencies\"><a href=\"#4-2-Fix-Data-Dependencies\" class=\"headerlink\" title=\"4.2 Fix Data Dependencies\"></a>4.2 Fix Data Dependencies</h3><p>The most challenging part of Loop Rotation is the update of data dependencies<br>(refer to steps 3 and 4 of the algorithm).</p>\n<h4 id=\"Update-conditional-test-operands\"><a href=\"#Update-conditional-test-operands\" class=\"headerlink\" title=\"Update conditional test operands\"></a>Update conditional test operands</h4><p>In original while&#x2F;for loop, a critical edge is inserted at the<br>end of each iteration, Phi values are updated. All subsequent<br>uses of Phi rely on updated values. However, when converted<br>to a do-while loop, Phi nodes may be used at the end of each<br>iteration before they are updated. Therefore, we need to<br>replace all subsequent uses of Phi with use of Phi parameter.<br>This way, it is equivalent to using updated values of Phi<br>values. Here is a simple example:</p>\n<p>Normal case, if v2 uses v1 phi, and the backedge operand v4<br>of v1 phi is located in the loop latch block, we only need to<br>modify the usage of v1 by v2 to the usage of v4. This prevents<br>loss of updates, and the dominance relationship will not be<br>broken even after v2 is moved to the loop latch.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before:</span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"> v2 = v1 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = const 512</span><br><span class=\"line\"></span><br><span class=\"line\">After:</span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = const 512</span><br><span class=\"line\"> v2 = v4 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<p>After updating uses of val, we may create yet another cyclic<br>dependency, i.e.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"> v2 = v1 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v4 = v2 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">After updating iarg of val to newUse, it becomes</span><br><span class=\"line\"></span><br><span class=\"line\"> loop header:</span><br><span class=\"line\"> v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\"> loop latch:</span><br><span class=\"line\"> v2 = v4 + 1   ;;; cyclic dependency</span><br><span class=\"line\"> v4 = v2 + 1</span><br><span class=\"line\"> If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<p>This is similiar to below case, and it would be properly handled<br>by updateMovedUses. For now, we just skip it to avoid infinite<br>recursion.</p>\n<p>If there is a value v1 in the loop header that is used to define<br>a v2 phi in the same basic block, and this v2 phi is used in<br>turn to use the value v1, there is a cyclic dependencies, i.e.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v2)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop body, loop exit</span><br></pre></td></tr></table></figure>\n\n<p>In this case, we need to first convert the v1 phi into its<br>normal form, where its back edge parameter uses the value defined<br>in the loop latch.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop body, loop exit</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v2</span><br></pre></td></tr></table></figure>\n\n<p>After this, the strange v1 phi is treated in the same way as<br>other phis. After moving the conditional test to the loop latch,<br>the relevant parameters will also be updated, i.e., v2 will<br>use v3 instead of v1 phi:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v2</span><br><span class=\"line\">v2 = v3 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n\n<p>Finally, since v3 is use of v2, after moving v2 to the loop<br>latch, updateMovedUses will update these uses and insert a<br>new v4 Phi.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, v3)</span><br><span class=\"line\">v4 = phi(v2&#x27;, v2)    ;;; v2&#x27; lives in loop guard</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v3 = Copy v4</span><br><span class=\"line\">v2 = v3 + 1</span><br><span class=\"line\">If v2 &lt; 3 -&gt; loop header, loop exit</span><br></pre></td></tr></table></figure>\n<h4 id=\"Update-uses-of-moved-Values-because-these-defs-no-longer-dominates-uses-after-they-were-moved-to-loop-latch\"><a href=\"#Update-uses-of-moved-Values-because-these-defs-no-longer-dominates-uses-after-they-were-moved-to-loop-latch\" class=\"headerlink\" title=\"Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch\"></a>Update uses of moved Values because these defs no longer dominates uses after they were moved to loop latch</h4><p>If the loop conditional test is “trivial”, we will move the chain of this<br>conditional test values to the loop latch, after that, they may not dominate<br>the in-loop uses anymore:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header</span><br><span class=\"line\">v1 = phi(0, ...)</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 ...</span><br><span class=\"line\"></span><br><span class=\"line\">loop body:</span><br><span class=\"line\">v4 = v2 - 1</span><br></pre></td></tr></table></figure>\n\n<p>So we need to create a new phi v5 at the loop header to merge the control flow<br>from the loop guard to the loop header and the loop latch to the loop header<br>and use this phi to replace the in-loop use v4. e.g.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop header:</span><br><span class=\"line\">v1 = phi(0, ...)</span><br><span class=\"line\">v5 = phi(v2&#x27;, v2)     ;;; v2&#x27; lives in loop guard</span><br><span class=\"line\"></span><br><span class=\"line\">loop body:</span><br><span class=\"line\">v4 = v5 - 1</span><br><span class=\"line\"></span><br><span class=\"line\">loop latch:</span><br><span class=\"line\">v2 = v1 + 1</span><br><span class=\"line\">If v2 &lt; 3 ...</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Add-corresponding-argument-for-phis-at-loop-exits-since-new-edge-from-loop-guard-to-loop-exit-had-been-created\"><a href=\"#Add-corresponding-argument-for-phis-at-loop-exits-since-new-edge-from-loop-guard-to-loop-exit-had-been-created\" class=\"headerlink\" title=\"Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created\"></a>Add corresponding argument for phis at loop exits since new edge from loop guard to loop exit had been created</h4><p>Loop header no longer dominates loop exit, a new edge from loop guard to loop<br>exit is created, this is not reflected in proxy phis in loop exits, i.e. these<br>proxy phis miss one argument that comes from loop guard, we need to reconcile<br>the divergence</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                              loop guard</span><br><span class=\"line\">                                    |</span><br><span class=\"line\">loop exit               loop exit  /</span><br><span class=\"line\">    |          =&gt;            |    /</span><br><span class=\"line\">v1=phi(v1)              v1=phi(v1 v1&#x27;) &lt;= add missing g2e argument v1&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>Since LCSSA ensures that all loop uses are closed, i.e. any out-of-loop uses<br>are replaced by proxy phis in loop exit, we only need to add missing argument<br>v1’ to v1 proxy phi</p>\n<h4 id=\"Update-proxy-phi-to-use-the-loop-phi’s-incoming-argument-which-comes-from-loop-latch-since-loop-latch-may-terminate-the-loop-now\"><a href=\"#Update-proxy-phi-to-use-the-loop-phi’s-incoming-argument-which-comes-from-loop-latch-since-loop-latch-may-terminate-the-loop-now\" class=\"headerlink\" title=\"Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now\"></a>Update proxy phi to use the loop phi’s incoming argument which comes from loop latch since loop latch may terminate the loop now</h4><p>Loop latch now terminates the loop. If proxy phi uses the loop phi that lives<br>in loop header, it should be replaced by using the loop phi’s incoming argument<br>which comes from loop latch instead, this avoids losing one update.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before:</span><br><span class=\"line\">  loop header:</span><br><span class=\"line\">  v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\">  loop latch:</span><br><span class=\"line\">  v4 = v1 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">  loop exit</span><br><span class=\"line\">  v3 = phi(v1, ...)</span><br><span class=\"line\"></span><br><span class=\"line\">After:</span><br><span class=\"line\">  loop header:</span><br><span class=\"line\">  v1 = phi(0, v4)</span><br><span class=\"line\"></span><br><span class=\"line\">  loop latch:</span><br><span class=\"line\">  v4 = v1 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">  loop exit</span><br><span class=\"line\">  v3 = phi(v4, ...)  ;; use v4 instead of v1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-Bug-Fix\"><a href=\"#5-Bug-Fix\" class=\"headerlink\" title=\"5. Bug Fix\"></a>5. Bug Fix</h2><p>The loop exit created by BlockJumpTable will not be discovered by <code>findExits()</code>.</p>\n<p><img src=\"/../images/bug_jmptable_exit.svg\" alt=\"image\"></p>\n<p>The current loop exits are only b23 and b43, but the expected ones should include b10 and b13.</p>\n<h2 id=\"6-Performance-Regression\"><a href=\"#6-Performance-Regression\" class=\"headerlink\" title=\"6. Performance Regression\"></a>6. Performance Regression</h2><h3 id=\"6-1-block-layout\"><a href=\"#6-1-block-layout\" class=\"headerlink\" title=\"6.1 block layout\"></a>6.1 block layout</h3><p>In original block layout algorithm, regardless of whether successors of the current basic block have <code>likely</code> attribute, the layout algorithm would place each successor right after the current basic block one by one. The improved algorithm employs a greedy approach, aiming to allocate the basic blocks of a “trace” together as much as possible, in order to minimize excessive jumps. i.e. For given IR:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1:</span><br><span class=\"line\">BlockIf -&gt; b2 b3 (likely)</span><br><span class=\"line\"></span><br><span class=\"line\">b2:</span><br><span class=\"line\">BlockPlain-&gt;b4</span><br><span class=\"line\"></span><br><span class=\"line\">b4:</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>The final block orders are as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baseline:</span><br><span class=\"line\">b1 b2 b3 b4</span><br><span class=\"line\"></span><br><span class=\"line\">opt:</span><br><span class=\"line\">b1 b2 b4 b3</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-2-register-allocation\"><a href=\"#6-2-register-allocation\" class=\"headerlink\" title=\"6.2 register allocation\"></a>6.2 register allocation</h3><p>After loop rotation, there are some significant performance regression. Taking the strconv.Atoi benchmark as an example, the performance deteriorates by about 30%. In the following example:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; baseline</span><br><span class=\"line\">b12</span><br><span class=\"line\">00025  JMP 30</span><br><span class=\"line\">00026  LEAQ (BX)(BX*4), R8</span><br><span class=\"line\">00027  MOVBLZX DI, DI</span><br><span class=\"line\">00028  INCQ AX</span><br><span class=\"line\">00029  LEAQ (DI)(R8*2), BX</span><br><span class=\"line\">00030  CMPQ AX, SI</span><br><span class=\"line\">b18</span><br><span class=\"line\">00031  JGE 38</span><br><span class=\"line\">00032  MOVBLZX (DX)(AX*1), DI</span><br><span class=\"line\">00033  ADDL $-48, DI</span><br><span class=\"line\">00034  CMPB DI, $9</span><br><span class=\"line\">b19</span><br><span class=\"line\">00035  JLS 26</span><br><span class=\"line\"></span><br><span class=\"line\">;; opt</span><br><span class=\"line\">b27</span><br><span class=\"line\">00027  JMP 29</span><br><span class=\"line\">00028  MOVQ R8, AX</span><br><span class=\"line\">00029  MOVBLZX (DX)(AX*1), DI</span><br><span class=\"line\">00030  ADDL $-48, DI</span><br><span class=\"line\">00031  CMPB DI, $9</span><br><span class=\"line\">b19</span><br><span class=\"line\">00032  JHI 40</span><br><span class=\"line\">00033  LEAQ 1(AX), R8</span><br><span class=\"line\">00034  LEAQ (BX)(BX*4), BX</span><br><span class=\"line\">00035  MOVBLZX DI, DI</span><br><span class=\"line\">00036  LEAQ (DI)(BX*2), BX</span><br><span class=\"line\">00037  CMPQ SI, R8</span><br><span class=\"line\">b20</span><br><span class=\"line\">00038  JGT 28</span><br><span class=\"line\">b20</span><br><span class=\"line\">00039  JMP 43</span><br></pre></td></tr></table></figure>\n\n<p>In the code generated by the baseline, the loop includes 10 instructions <code>[26-35]</code>, whereas the optimized code contains 11 instructions <code>[28-38]</code>. This is because the baseline’s loop increment instruction <code>i++</code> produced <code>incq ax</code>, while the optimized code generated is:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00028  MOVQ R8, AX</span><br><span class=\"line\">...</span><br><span class=\"line\">00033  LEAQ 1(AX), R8</span><br></pre></td></tr></table></figure>\n\n<p>The culprit is empty basic block created during the split critical edge after rotation, which affects the logic of register allocation;</p>\n<p><img src=\"/../images/bad-regalloc-regression.png\" alt=\"image\"></p>\n<p>During the register allocation process, for the instruction <code>v82 = ADDQconst &lt;int&gt; [1] v59</code>, the register allocator checks if v59 is in the next basic block and examines the expected register for v59. For example, if v59 is in the next basic block and its expected register is R8, then the register allocator would also allocate the R8 register for <code>v82 = ADDQconst &lt;int&gt; [1] v59</code>, because the input and result are in the same register, allowing the production of <code>incq</code>. However, after loop rotation, the next basic block for v82 is the newly inserted empty basic block from the split critical edge, preventing the register allocator from knowing the expected register for v59, so v82 and v59 end up being allocated to different registers, R8 and RAX, resulting in an extra <code>mov</code> instruction. The proposed fix is to skip empty basic block and directly check the next non-empty basic block for the expected register.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmknfsoct00049dpxh977ejrf","category_id":"cmknfoyfh00009dpx9nlpbiaw","_id":"cmknfsocu00059dpxfov384h4"},{"post_id":"cmknft1w300069dpxdmbtcxml","category_id":"cmkng22em00000opxa4epgqhn","_id":"cmkng22eo00020opx7acnayfh"},{"post_id":"cmknft1w300069dpxdmbtcxml","category_id":"cmkng22en00010opx4owtdsym","_id":"cmkng22eo00030opx95xp4o44"},{"post_id":"cmkng4hxj000034pxfau714m9","category_id":"cmkng4iv5000134px2vcu205u","_id":"cmkng4iv5000234pxghjih7bm"},{"post_id":"cmkng84wz000334px4ibp9jfc","category_id":"cmkng22em00000opxa4epgqhn","_id":"cmkngeohj0000zmpx2y6x25td"},{"post_id":"cmkng84wz000334px4ibp9jfc","category_id":"cmkng22en00010opx4owtdsym","_id":"cmkngeohj0001zmpxfy8a4e4v"}],"PostTag":[],"Tag":[]}}